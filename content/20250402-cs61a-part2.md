---
id: 20250402-cs61a-part2
aliases:
  - cs61a-part2
tags: []
---

# cs61a-part2

[[1737418909-cs61a|cs61a]]
[COMPOSING PROGRAMS](https://composingprograms.netlify.app/)
[CS 61A Spring 2025](https://cs61a.org/)

# Tree

![](20250402-cs61a-part2/2025-04-02-05-48-16.png)

![](20250402-cs61a-part2/2025-04-02-02-12-57.png)

![](20250402-cs61a-part2/2025-04-02-02-13-11.png)

![](20250402-cs61a-part2/2025-04-02-02-14-16.png)

![](20250402-cs61a-part2/2025-04-02-02-28-50.png)

![](20250402-cs61a-part2/2025-04-02-02-56-37.png)

![](20250402-cs61a-part2/2025-04-02-04-39-10.png)

![](20250402-cs61a-part2/2025-04-02-04-40-40.png)

- it add 1 to all the node including the lable

![](20250402-cs61a-part2/2025-04-02-04-42-11.png)

- increment the leaves only

![](20250402-cs61a-part2/2025-04-02-04-48-29.png)

first print tree

```python
def print_tree(t, indent=0):
    print(' '*indent, label(t)) # could adding str() to label
    for b in branches(t):
        print_tree(b, indent + 1)
```

- fib_tree make it much easier to see the difference

---

![](20250402-cs61a-part2/2025-04-02-04-57-13.png)

![](20250402-cs61a-part2/2025-04-02-04-58-30.png)

![](20250402-cs61a-part2/2025-04-02-05-03-12.png)

```python
numbers = tree(3, [tree(4), tree(5, [tree(6)])])
haste = tree('h', [tree('a', [tree('s'),
                              tree('t')]),
                   tree('e')])

>>> haste
['h', ['a', ['s'], ['t']], ['e']]
>>> print_tree(haste)
 h
  a
   s
   t
  e
  >>> label(haste)
  'h'
  >>> branches(haste)
  [['a', ['s'], ['t']], ['e']]

```

- adding a function

```python

def print_sums(t, so_far):
    so_far = so_far + label(t)
    if is_leaf(t):
        print(so_far)
    else:
        for b in branches(t):
            print_sums(b, so_far)
  >>> numbers
  [3, [4], [5, [6]]]
  >>> print_sums(numbers,0)
  7
  14
  >>>
```

The expression `not branches(list)` will return:

- **`True`** → when `branches(list)` is an empty list (`[]`), meaning `list` has no branches (only a root).
- **`False`** → when `branches(list)` is **not** empty, meaning `list` has at least one branch.

### Example Scenarios:

```python
tree1 = [1]          # Only root, no branches
tree2 = [1, [2], [3]]  # Root with branches

print(not branches(tree1))  # True (empty branches)
print(not branches(tree2))  # False (has branches)
```

So, `is_leaf(tree)` will return `True` only when the tree has no branches.

- empty list -> false (TF game)
  ![](20250402-cs61a-part2/2025-04-02-05-47-05.png)

![](20250402-cs61a-part2/2025-04-02-06-14-12.png)

```python
>>> print_sums(numbers,0)
7
14
>>> numbers
[3, [4], [5, [6]]]
>>> print_sums(numbers,0)
7
14
>>> print_tree(numbers)
 3
  4
  5
   6

```

---

![](20250402-cs61a-part2/2025-04-02-06-42-06.png)

find total path to get the number total

- how many way to get the ans

![](20250402-cs61a-part2/2025-04-02-06-46-24.png)

---

![](20250402-cs61a-part2/2025-04-02-23-30-55.png)

- review :->

(a) -> variable -> 1

second(thing ) into a fuction: -> into return (y)

a -> y , so y = 1

g() call back parent fuction (a / 1)

lambda y:

```python
>>> a = 3
...
... def f(g):
...     a = 2
...     return lambda y: a* g(y)
... f(lambda y : a+y )(a)
...
12
>>>

(a) -> into another (variable)

  - indent -> trace
  last step is *2

```

---

![](20250402-cs61a-part2/2025-04-02-23-50-14.png)

- return None -> ending the fuction

![](20250402-cs61a-part2/2025-04-02-23-52-37.png)

- brute force

![](20250402-cs61a-part2/2025-04-02-23-53-35.png)

![](20250402-cs61a-part2/2025-04-02-23-56-07.png)

y = last ( variable )

search (f) -> anyfn that f(self) = y , if true = return x

---

![](20250402-cs61a-part2/2025-04-03-00-06-41.png)

![](20250402-cs61a-part2/2025-04-03-00-08-49.png)

- return None make a back to previous recurion fn 🤔
- damn , so that's why it print both case !!!!

<Each cascade frame is from a
different call to cascade.

-Until the Return value appears,
that call has not completed.

«Any statement can appear before
or after the recursive call.

## ![](20250402-cs61a-part2/2025-04-03-00-10-56.png)

shorter version:

```python
def cascade(n):
    print(n)
    if n>10:
        cascade(n//10)
        print(n)
```

longer implemenation is more clear (base case, recursive case , so first one is
better)

now it is inverse cascade:

![](20250402-cs61a-part2/2025-04-03-00-15-38.png)

---

![](20250402-cs61a-part2/2025-04-03-00-16-16.png)

![](20250402-cs61a-part2/2025-04-03-00-16-31.png)

![](20250402-cs61a-part2/2025-04-03-00-19-26.png)

---

- Tree recursion

![](20250402-cs61a-part2/2025-04-03-00-37-46.png)

```python
>>> fib(0)
0
>>> fib(1)
1
>>> fib(3)
2
>>> fib(5)
5
>>> fib(6)
8
>>> fib(8)
21
>>>
  @trace
def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n - 2) + fib(n - 1)



```

- using ucb trace.py to trace the recursion function 🤩🤩🤩

ucb python file:

```python

"""The UCB module contains functions specific to 61A projects at UC Berkeley."""

import code
import functools
import inspect
import re
import signal
import sys


def main(fn):
    """Call fn with command line arguments.  Used as a decorator.

    The main decorator marks the function that starts a program. For example,

    @main
    def my_run_function():
        # function body

    Use this instead of the typical __name__ == "__main__" predicate.
    """
    if inspect.stack()[1][0].f_locals['__name__'] == '__main__':
        args = sys.argv[1:] # Discard the script name from command line
        fn(*args) # Call the main function
    return fn

_PREFIX = ''
def trace(fn):
    """A decorator that prints a function's name, its arguments, and its return
    values each time the function is called. For example,

    @trace
    def compute_something(x, y):
        # function body
    """
    @functools.wraps(fn)
    def wrapped(*args, **kwds):
        global _PREFIX
        reprs = [repr(e) for e in args]
        reprs += [repr(k) + '=' + repr(v) for k, v in kwds.items()]
        log('{0}({1})'.format(fn.__name__, ', '.join(reprs)) + ':')
        _PREFIX += '    '
        try:
            result = fn(*args, **kwds)
            _PREFIX = _PREFIX[:-4]
        except Exception as e:
            log(fn.__name__ + ' exited via exception')
            _PREFIX = _PREFIX[:-4]
            raise
        # Here, print out the return value.
        log('{0}({1}) -> {2}'.format(fn.__name__, ', '.join(reprs), result))
        return result
    return wrapped


def log(message):
    """Print an indented message (used with trace)."""
    print(_PREFIX + re.sub('\n', '\n' + _PREFIX, str(message)))


def log_current_line():
    """Print information about the current line of code."""
    frame = inspect.stack()[1]
    log('Current line: File "{f[1]}", line {f[2]}, in {f[3]}'.format(f=frame))


def interact(msg=None):
    """Start an interactive interpreter session in the current environment.

    On Unix:
      <Control>-D exits the interactive session and returns to normal execution.
    In Windows:
      <Control>-Z <Enter> exits the interactive session and returns to normal
      execution.
    """
    # evaluate commands in current namespace
    frame = inspect.currentframe().f_back
    namespace = frame.f_globals.copy()
    namespace.update(frame.f_locals)

    # exit on interrupt
    def handler(signum, frame):
        print()
        exit(0)
    signal.signal(signal.SIGINT, handler)

    if not msg:
        _, filename, line, _, _, _ = inspect.stack()[1]
        msg = 'Interacting at File "{0}", line {1} \n'.format(filename, line)
        msg += '    Unix:    <Control>-D continues the program; \n'
        msg += '    Windows: <Control>-Z <Enter> continues the program; \n'
        msg += '    exit() or <Control>-C exits the program'

    code.interact(msg, None, namespace)
```

- with trace(ubc)

```python
>>> fib(0)
fib(0):
fib(0) -> 0
0
>>> fib(1)
fib(1):
fib(1) -> 1
1
>>> fib(2)
fib(2):
    fib(0):
    fib(0) -> 0
    fib(1):
    fib(1) -> 1
fib(2) -> 1
1
>>> fib(3)
fib(3):
    fib(1):
    fib(1) -> 1
    fib(2):
        fib(0):
        fib(0) -> 0
        fib(1):
        fib(1) -> 1
    fib(2) -> 1
fib(3) -> 2
2


```

---

- tree partitions

![](20250402-cs61a-part2/2025-04-03-01-06-47.png)

- counting 6, but max for using number 4

![](20250402-cs61a-part2/2025-04-03-01-07-23.png)

![](20250402-cs61a-part2/2025-04-03-01-08-47.png)

- spliting half

left = 6-4

right =

explore two possibilities:

- use at least one 4
- don't use any 4

![](20250402-cs61a-part2/2025-04-03-01-10-43.png)

Decomposing problem

- count_partitions(2, 4)

- count_partitions(6, 3)

---

again , at least 3 , don't use 3

finally , sum them all

![](20250402-cs61a-part2/2025-04-03-01-14-10.png)

```python
@trace
def count_partitions(n, m):
    if n == 0:
        return 1
    elif n < 0:
        return 0
    elif m == 0:
        return 0
    else:
        with_m = count_partitions(n - m, m)
        without_m = count_partitions(n, m - 1)
        return with_m + without_m

>>> count_partitions(2,4)
count_partitions(2, 4):
    count_partitions(-2, 4):
    count_partitions(-2, 4) -> 0
    count_partitions(2, 3):
        count_partitions(-1, 3):
        count_partitions(-1, 3) -> 0
        count_partitions(2, 2):
            count_partitions(0, 2):
            count_partitions(0, 2) -> 1
            count_partitions(2, 1):
                count_partitions(1, 1):
                    count_partitions(0, 1):
                    count_partitions(0, 1) -> 1
                    count_partitions(1, 0):
                    count_partitions(1, 0) -> 0
                count_partitions(1, 1) -> 1
                count_partitions(2, 0):
                count_partitions(2, 0) -> 0
            count_partitions(2, 1) -> 1
        count_partitions(2, 2) -> 2
    count_partitions(2, 3) -> 2
count_partitions(2, 4) -> 2
2

```

(4,6)

```python
1.  6 = 2 + 4
2.  6 = 1 + 1 + 4
3.  6 = 3 + 3
4.  6 = 1 + 2 + 3
5.  6 = 1 + 1 + 1 + 3
6.  6 = 2 + 2 + 2
7.  6 = 1 + 1 + 2 + 2
8.  6 = 1 + 1 + 1 + 1 + 2
9.  6 = 1 + 1 + 1 + 1 + 1 + 1

```

![](20250402-cs61a-part2/2025-04-03-01-30-26.png)

[(162) Lists - YouTube](https://www.youtube.com/watch?v=-Q45UcQ2XJk&list=PL6BsET-8jgYVfI7chdrXciKy8CP10tOcl)

[[777-decorator]]

---

digit[3] or getitem(digits, 3) -> same

![](20250402-cs61a-part2/2025-04-03-09-40-12.png)

- containers

```python
>>> digits=[1,8,2,8]
>>> 1 in digits
True
>>> 2 in digits
True
>>> 5 not in digits
True
>>> not(5 in digits)
True
>>> '1' == 1
False
>>> '1' in digits
False
>>> [1,8] in digits
False
>>> [1,2] in [3,[1,2],4]
True
>>> [1,2] in [3,[[1,2]],4]
False
>>>

```

---

- statements

```python
>>> def count(s, value):
...     total,index=0,0
...     while index<len(s):
...         element=s[index]
...         if element == value:
...             total = total +1
...         index=index+1
...     return total
...
>>> count([1,2,1,2,1],1)
3
# refactor into python prefer:
def count_new(s, value):
    total = 0
    for element in s:
        if element == value:
            total += 1
    return total
```

![](20250402-cs61a-part2/2025-04-03-09-52-10.png)

![](20250402-cs61a-part2/2025-04-03-09-53-12.png)

- unpack the pairs (only work in same length sequence)
  for x,y in pairs:
  if x==y:

- range:

![](20250402-cs61a-part2/2025-04-03-09-57-51.png)

- list(range())

![](20250402-cs61a-part2/2025-04-03-10-03-07.png)

for \_ in range(3):

- just loop 3 time

---

- list comprehensions

![](20250402-cs61a-part2/2025-04-03-10-03-58.png)

```python
>>> odds =[1,3,5,7,9]
>>> [x+1 ofr x in odds]
  File "<python-input-64>", line 1
    [x+1 ofr x in odds]
     ^^^^^^^
SyntaxError: invalid syntax. Perhaps you forgot a comma?
>>> [x+1 for x in odds]
[2, 4, 6, 8, 10]
>>> [x+2 for x in odds]
[3, 5, 7, 9, 11]
>>> [x**2 for x in odds]
[1, 9, 25, 49, 81]
>>> x**2 for x in odds
  File "<python-input-68>", line 1
    x**2 for x in odds
         ^^^
SyntaxError: invalid syntax
>>> [x**2 for x in odds]
[1, 9, 25, 49, 81]
>>> (x**2 for x in odds)
<generator object <genexpr> at 0x7a5e2cddcd40>
>>> list((x**2 for x in odds))
[1, 9, 25, 49, 81]
>>> list(x**2 for x in odds)
[1, 9, 25, 49, 81]
>>> [x**2 for x in list(x**2 for x in odds)]
[1, 81, 625, 2401, 6561]
>>> [x for x in odds if 25 %x ==0]
[1, 5]

## other list compre:
>>> def divisor(n):
...     return [1] + [x for x in range(2,n) if n%x==0]
...
>>> divisor(1)
[1]
>>> divisor(4)
[1, 2]
>>> divisor(9)
[1, 3]
>>> list(range(2,4))
[2, 3]
>>> list(range(2,9))
[2, 3, 4, 5, 6, 7, 8]
>>>
  ... def divisor(n):
...     return [1] + [x for x in range(2,n) if x%2==0]
  ... def divisor(n):
...     return [1] + [x for x in range(2,n+1) if x%2==0]

```

- range(2,n+1)

![](20250402-cs61a-part2/2025-04-03-10-19-31.png)

- `return s[0] + fn(s[1:])`
  adding the first element to the sum of the rest of the element

- normal recursion using n-1 etc , this just adjust the slice number

  tree recursion

![](20250402-cs61a-part2/2025-04-03-10-24-31.png)

similar to previous problem?:

```
def count_partitions(n, m):
    if n == 0:
        return 1
    elif n < 0:
        return 0
    elif m == 0:
        return 0
    else:
        with_m = count_partitions(n - m, m)
        without_m = count_partitions(n, m - 1)
        return with_m + without_m


```

- nope

![](20250402-cs61a-part2/2025-04-03-10-38-35.png)

---

next chapter :
[(162) Box-and-Pointer Notation - YouTube](https://www.youtube.com/watch?v=aSqOiUZg7kQ&list=PL6BsET-8jgYW50w7isVJS3YumstvFX1LY)

---

tree recusion dis:

![](20250402-cs61a-part2/2025-04-03-21-15-19.png)
The most important thing to remember about lists is that a non-empty list s can be split into its first element s[0] and the rest of the list s[1:].

```python
>>> s = [2, 3, 6, 4]
>>> s[0]
2
>>> s[1:]
[3, 6, 4]

using these to learn frist rather than append
```

sums(n,m)
n = total
m = max
return `[all list]`

q2

```python
def max_product(s):
    """Return the maximum product of non-consecutive elements of s.

    >>> max_product([10, 3, 1, 9, 2])   # 10 * 9
    90
    >>> max_product([5, 10, 5, 10, 5])  # 5 * 5 * 5
    125
    >>> max_product([])                 # The product of no numbers is 1
    1
    """


```

Good question! Let's break it down and understand why `s[1:] * max_product(s[1+2:])` is **incorrect**, while `non_first = max_product(s[1:])` is **correct**.

---

### **Understanding the "non-first" case**

The **goal of the "non-first" choice** is to **skip** the first element and find the best product from the **rest of the list**.

#### **Why is this wrong?**

```python
non_first = s[1:] * max_product(s[1+2:])
```

1. **Issue with Multiplication (`s[1:] * something`)**

   - `s[1:]` is **a list**, not a single number.
   - You cannot multiply a list by a number like this; it's a **type error**.

2. **Incorrect Skipping Logic**
   - `s[1+2:]` skips two elements from `s[1:]`, but the "non-first" case **only means skipping the first element**.
   - You should not force skipping another element in this case.

---

### **Why is this correct?**

```python
non_first = max_product(s[1:])
```

1. **It correctly skips only the first element**

   - The purpose of "non-first" is just to **ignore the first element** and continue processing the rest normally.
   - We pass `s[1:]` (everything except the first element) to `max_product()`, letting the function decide the best product from there.

2. **Recursive structure remains intact**
   - `max_product(s[1:])` naturally handles choosing whether to include elements at `s[1]` or not.
   - No need to manually skip more elements.

---

### **Example Breakdown**

#### Example: `s = [10, 3, 1, 9, 2]`

Let's see how each approach behaves.

##### **Your incorrect approach**

```python
non_first = s[1:] * max_product(s[1+2:])  # Incorrect!
```

- `s[1:] = [3, 1, 9, 2]`
- `max_product(s[1+2:]) = max_product([9, 2])`
- But `s[1:] * max_product([9, 2])` is invalid because `s[1:]` is a **list**, and we cannot multiply a list by a number.

##### **Correct approach**

```python
non_first = max_product(s[1:])
```

- We correctly pass `[3, 1, 9, 2]` into `max_product()`, letting it handle the computation recursively.

---

### **Final Takeaway**

- The **"first" case** involves multiplying because we actively pick an element.
- The **"non-first" case** just moves forward without multiplying, letting recursion handle it.
- **Don't manually skip extra elements for "non-first"; just call `max_product(s[1:])`.**

Does this explanation help? 😊

```python
# Official (alternative) version
return max(s[0] * max_product(s[2:]), s[1] * max_product(s[3:]))
```

### 🔍 Key Difference:

Instead of just **skipping the first element**, the official version tries **both**:

- Taking `s[0]` and skipping `s[1]`
- Taking `s[1]` and skipping `s[2]`

### ✅ Why it's valid:

This version is **exploring more options**, not just one recursive path. It's still selecting **non-consecutive elements**, but now it considers:

- What if we start by skipping the first element, and **then** pick `s[1]`?

It might give a better product in some cases.

### 🧠 Summary:

- Your version is recursive and safe: `max(s[0]*..., max_product(s[1:]))`
- The alternative tries **both `s[0]` and `s[1]` as starting points**.

Both are valid; the official one explores a broader search space.

Want to see an example where this difference matters?

- official ans-> no need using +1, just `[0:] and [2:] & [1] and [3]` 🔥

---

```python
def sums(n, m):
    """Return lists that sum to n containing positive numbers up to m that
    have no adjacent repeats.

    >>> sums(5, 1)
    []
    >>> sums(5, 2)
    [[2, 1, 2]]
    >>> sums(5, 3)
    [[1, 3, 1], [2, 1, 2], [2, 3], [3, 2]]
    >>> sums(5, 5)
    [[1, 3, 1], [1, 4], [2, 1, 2], [2, 3], [3, 2], [4, 1], [5]]
    >>> sums(6, 3)
    [[1, 2, 1, 2], [1, 2, 3], [1, 3, 2], [2, 1, 2, 1], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]
    """
    if n < 0:
        return []
    if n == 0:
        sums_to_zero = []     # The only way to sum to zero using positives
        return [sums_to_zero] # Return a list of all the ways to sum to zero
    result = []
    for k in range(1, m + 1):
        result = result + [ ___ for rest in ___ if rest == [] or ___ ]
    return result
```

![](20250402-cs61a-part2/2025-04-03-22-46-40.png)

### 📌 Line in Question:

```python
result = result + [[k] + rest for rest in sums(n - k, m) if rest == [] or rest[0] != k]
```

---

### 🧠 First, let’s understand the **goal**

We're trying to **build all possible lists** of numbers that:

- Add up to `n`
- Use only numbers `1` to `m`
- Have **no adjacent duplicates**

---

### 🧱 Break the line into smaller parts:

#### Part 1: The loop

```python
for rest in sums(n - k, m)
```

This is the **recursive part**.

- We already chose a number `k` (in a loop from `1` to `m`)
- So we subtract `k` from the target: `n - k`
- And we ask: _What are all the valid lists that sum to `n - k`?_
- Those results are stored in `rest`

So `rest` is a valid list **after we've already picked `k`**

---

#### Part 2: The condition

```python
if rest == [] or rest[0] != k
```

This is the **adjacent repeat check**.

- We don’t want to allow something like `[2, 2, 1]`
- So we check:
  - If `rest` is empty (`[]`) → OK, there’s nothing to compare
  - Otherwise: make sure `rest[0] != k`, so `k` isn’t repeated

#### ✅ Example:

Say `k = 2` and `rest = [2, 1]`, then:

- `rest[0] == k` → ❌ skip it (would give `[2, 2, 1]`, which has adjacent `2`s)

Say `rest = [1, 2]`:

- `rest[0] != k` → ✅ keep it (result would be `[2, 1, 2]`)

---

#### Part 3: The result building

```python
[[k] + rest ...]
```

Once we know `rest` is valid:

- We **add `k` to the front** of it → `[k] + rest`
- That’s one of our valid result lists

---

#### Part 4: Append to final list

```python
result = result + ...
```

We're collecting all valid combinations, so we keep adding to `result`

---

### ✅ Final Visual Summary:

For every number `k` from `1` to `m`:

- Get all valid sublists that sum to `n - k`
- For each one:
  - If it doesn’t start with `k`, then:
    - Add `k` in front
    - Save it in the final list

---

### 🧪 Tiny Example:

`sums(3, 2)` — we want to find all valid lists of 1s and 2s that add up to 3, no adjacent repeats.

Here’s what would happen:

- Try `k = 1`

  - `n - k = 2`
  - Call `sums(2, 2)` → maybe gives `[[2], [1, 1]]`
  - Check: can we put 1 in front?
    - `[1, 1]` ❌ skip (1 == 1)
    - `[2]` ✅ keep → `[1, 2]`

- Try `k = 2`
  - `n - k = 1`
  - Call `sums(1, 2)` → maybe gives `[[1]]`
  - Can we put 2 in front?
    - `[1]` ✅ → `[2, 1]`

✅ Final result: `[[1, 2], [2, 1]]`

---

Let me know if you'd like this rewritten as a for-loop version — sometimes that's easier to read than list comprehensions.

```python
sums(5, 3):
    sums(4, 3):
        sums(3, 3):
            sums(2, 3):
                sums(1, 3):
                    sums(0, 3):
                    sums(0, 3) -> [[]]
                    sums(-1, 3):
                    sums(-1, 3) -> []
                    sums(-2, 3):
                    sums(-2, 3) -> []
                sums(1, 3) -> [[1]]
                sums(0, 3):
                sums(0, 3) -> [[]]
                sums(-1, 3):
                sums(-1, 3) -> []
            sums(2, 3) -> [[2]]
            sums(1, 3):
                sums(0, 3):
                sums(0, 3) -> [[]]
                sums(-1, 3):
                sums(-1, 3) -> []
                sums(-2, 3):
                sums(-2, 3) -> []
            sums(1, 3) -> [[1]]
            sums(0, 3):
            sums(0, 3) -> [[]]
        sums(3, 3) -> [[1, 2], [2, 1], [3]]
        sums(2, 3):
            sums(1, 3):
                sums(0, 3):
                sums(0, 3) -> [[]]
                sums(-1, 3):
                sums(-1, 3) -> []
                sums(-2, 3):
                sums(-2, 3) -> []
            sums(1, 3) -> [[1]]
            sums(0, 3):
            sums(0, 3) -> [[]]
            sums(-1, 3):
            sums(-1, 3) -> []
        sums(2, 3) -> [[2]]
        sums(1, 3):
            sums(0, 3):
            sums(0, 3) -> [[]]
            sums(-1, 3):
            sums(-1, 3) -> []
            sums(-2, 3):
            sums(-2, 3) -> []
        sums(1, 3) -> [[1]]
    sums(4, 3) -> [[1, 2, 1], [1, 3], [3, 1]]
    sums(3, 3):
        sums(2, 3):
            sums(1, 3):
                sums(0, 3):
                sums(0, 3) -> [[]]
                sums(-1, 3):
                sums(-1, 3) -> []
                sums(-2, 3):
                sums(-2, 3) -> []
            sums(1, 3) -> [[1]]
            sums(0, 3):
            sums(0, 3) -> [[]]
            sums(-1, 3):
            sums(-1, 3) -> []
        sums(2, 3) -> [[2]]
        sums(1, 3):
            sums(0, 3):
            sums(0, 3) -> [[]]
            sums(-1, 3):
            sums(-1, 3) -> []
            sums(-2, 3):
            sums(-2, 3) -> []
        sums(1, 3) -> [[1]]
        sums(0, 3):
        sums(0, 3) -> [[]]
    sums(3, 3) -> [[1, 2], [2, 1], [3]]
    sums(2, 3):
        sums(1, 3):
            sums(0, 3):
            sums(0, 3) -> [[]]
            sums(-1, 3):
            sums(-1, 3) -> []
            sums(-2, 3):
            sums(-2, 3) -> []
        sums(1, 3) -> [[1]]
        sums(0, 3):
        sums(0, 3) -> [[]]
        sums(-1, 3):
        sums(-1, 3) -> []
    sums(2, 3) -> [[2]]
sums(5, 3) -> [[1, 3, 1], [2, 1, 2], [2, 3], [3, 2]]
[[1, 3, 1], [2, 1, 2], [2, 3], [3, 2]]
```

---

Let’s take an easy example:  
`👉 sums(3, 2)`  
So:

- We want all combinations of 1s and 2s
- That sum to `3`
- And don’t have **adjacent repeats**

---

## 🔁 Step-by-step with simple loops

Let’s write the logic more clearly using regular loops:

```python
def sums(n, m):
    if n < 0:
        return []
    if n == 0:
        return [[]]  # Only one way to sum to zero

    result = []
    for k in range(1, m + 1):  # Try every number from 1 to m
        sublists = sums(n - k, m)  # Recursive call
        for rest in sublists:
            if rest == [] or rest[0] != k:  # No repeats
                result.append([k] + rest)   # Build the new list
    return result
```

---

## 🧠 What happens to `rest`?

Let’s trace `sums(3, 2)` step by step.

---

### First call: `sums(3, 2)`

Try `k = 1`:

- Call `sums(2, 2)`

---

### Second call: `sums(2, 2)`

Try `k = 1` again:

- Call `sums(1, 2)`

---

### Third call: `sums(1, 2)`

Try `k = 1`:

- Call `sums(0, 2)` → returns `[[]]`
- Now we loop over `rest in [[]]`
  - `rest = []` → ✅ pass the check
  - Add `[1] + []` → `[1]` ✅

Now `sums(1, 2)` → has `[ [1] ]` so far.

Try `k = 2`:

- Call `sums(-1, 2)` → returns `[]`  
  So done here.

Return: `sums(1, 2)` → `[[1]]`

---

### Back to `sums(2, 2)`

Now we’re still handling `k = 1`, and `sums(1, 2)` returned `[[1]]`

We loop:

- `rest = [1]`
- Check: is `rest[0] != k`? → `1 == 1` ❌ skip it!

Now try `k = 2`:

- Call `sums(0, 2)` → returns `[[]]`

Loop:

- `rest = []` → ✅
- Add `[2] + []` → `[2]`

Return: `sums(2, 2)` → `[[2]]`

---

### Back to `sums(3, 2)`

We’re at `k = 1`, and `sums(2, 2)` gave `[[2]]`

Loop:

- `rest = [2]` → `2 != 1` ✅
- Add `[1] + [2]` → `[1, 2]`

Now try `k = 2`:

- Call `sums(1, 2)` → returned `[[1]]`

Loop:

- `rest = [1]` → `1 != 2` ✅
- Add `[2] + [1]` → `[2, 1]`

---

### ✅ Final result of `sums(3, 2)`:

```
[[1, 2], [2, 1]]
```

---

## 🔄 How `rest` changes

It’s the result of the recursive call each time:

- `sums(0, 2)` → `[[]]`
- `sums(1, 2)` → `[[1]]`
- `sums(2, 2)` → `[[2]]`
- `sums(3, 2)` builds on that to form `[1, 2]`, `[2, 1]`

Each time you add a number `k`, you get **smaller problems**, and `rest` is the **partial solution** to that smaller problem.

---

### TL;DR:

- `rest` is a **partial solution** from a recursive call
- You’re trying to build on `rest` by adding a new number `k` in front
- But you **skip** it if `rest[0] == k` to avoid adjacent repeats

---

Want me to visualize it like a tree diagram?
