---
id: 20250302-modern-cpp
aliases:
  - modern-cpp
tags: []
created: 2025-09-08
modified: 2025-09-08T23:44:46
---

# modern-cpp

[huihut/interview: ğŸ“š C/C++ æŠ€æœ¯é¢è¯•åŸºç¡€çŸ¥è¯†æ€»ç»“ï¼ŒåŒ…æ‹¬è¯­è¨€ã€ç¨‹åºåº“ã€æ•°æ®ç»“æ„ã€ç®—æ³•ã€ç³»ç»Ÿã€ç½‘ç»œã€é“¾æ¥è£…è½½åº“ç­‰çŸ¥è¯†åŠé¢è¯•ç»éªŒã€æ‹›è˜ã€å†…æ¨ç­‰ä¿¡æ¯ã€‚This repository is a summary of the basic knowledge of recruiting job seekers and beginners in the direction of C/C++ technology, including language, program library, data structure, algorithm, system, network, link loading library, interview experience, recruitment, recommendation, etc.](https://github.com/huihut/interview)

std:library resources : codereport: youtube + explain




[codereport/Algorithms: STL Algorithm Cheat Sheet + example code from STL Algorithm Video Series.](https://github.com/codereport/Algorithms)

[Asio C++ Library](https://think-async.com/Asio/index.html) -> for cpp 20 network, low levelI/O (cross platforum)
> - [C++ è¯­è¨€è¶…è¯¦ç»†ç³»ç»Ÿå­¦ä¹ è·¯çº¿ï¼ˆ2025å¹´æœ€æ–°ï¼‰ | ç¼–ç¨‹æŒ‡åŒ—-è®¡ç®—æœºå­¦ä¹ æŒ‡å—](https://csguide.cn/roadmap/cpp/how_to_learn_cpp.html) -> useful

- [Linux C++ åå°å¼€å‘ç³»ç»Ÿå­¦ä¹ è·¯çº¿ï¼ˆ2025å¹´æœ€æ–°ï¼‰ | ç¼–ç¨‹æŒ‡åŒ—-è®¡ç®—æœºå­¦ä¹ æŒ‡å—](https://csguide.cn/roadmap/cpp/linux_cpp.html#_8-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F%E7%BA%A7%E7%BC%96%E7%A8%8B) -> part 2 , os csapp , low level courses
  [è¶…å…¨ C/C++ æŠ€æœ¯é¢è¯•å…«è‚¡æ–‡é¢è¯•é¢˜ï¼ï¼ˆ2025 å¹´æ›´æ–°ï¼‰ | ç¼–ç¨‹æŒ‡åŒ—-è®¡ç®—æœºå­¦ä¹ æŒ‡å—](https://csguide.cn/cpp/intro.html)
  [wuye9036/CppTemplateTutorial: ä¸­æ–‡çš„C++ Templateçš„æ•™å­¦æŒ‡å—ã€‚ä¸çŸ¥åä¹¦ç±C++ Templatesä¸åŒï¼Œè¯¥ç³»åˆ—æ•™ç¨‹å°†C++ Templatesä½œä¸ºä¸€é—¨å›¾çµå®Œå¤‡çš„è¯­è¨€æ¥è®²æˆï¼Œä»¥æ±‚å¸®åŠ©è¯»è€…å¯¹Meta-Programmingèä¼šè´¯é€šã€‚(æ­£åœ¨æ–½å·¥ä¸­)](https://github.com/wuye9036/CppTemplateTutorial)

[Redis è¶…è¯¦ç»†ç³»ç»Ÿå­¦ä¹ è·¯çº¿ï¼ˆ2025ï¼‰ | ç¼–ç¨‹æŒ‡åŒ—-è®¡ç®—æœºå­¦ä¹ æŒ‡å—](https://csguide.cn/roadmap/backend_middleware/how_to_learn_redis.html#%E4%B8%89%E3%80%81%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99)
[Career_planning_path/c_cppé¡¹ç›®åˆé›† at main Â· 0voice/Career_planning_path](https://github.com/0voice/Career_planning_path/tree/main/c_cpp%E9%A1%B9%E7%9B%AE%E5%90%88%E9%9B%86) -> **cpp lib, project**
[interview_internal_reference/2023adding.md at master Â· 0voice/interview_internal_reference](https://github.com/0voice/interview_internal_reference/blob/master/2023adding.md#309-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%A6%81%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0) -> **cpp 1000 interview question**

- **your own question bank form competiteve programming , either form testdata or usaco**

- [madskjeldgaard/cppman.nvim: Search cppman (cplusplus.com and cppreference) from within neovim](https://github.com/madskjeldgaard/cppman.nvim) nvim plugin
  [nvim/lua/plugins/tips.lua at master Â· BaoSiZe-bot/nvim](https://github.com/BaoSiZe-bot/nvim/blob/master/lua/plugins/tips.lua)

  2.1 ç³»çµ±å…¥é–€æ›¸ç±

      ã€ŠAccelerated C++ã€‹ï¼ˆç¾åœ‹æ–¯å¦ç¦å¤§å­¸çš„ç¶“å…¸æ•™æï¼‰
      ã€ŠC++ Primerã€‹ï¼ˆç¶“å¸¸è¢«æ¨è–¦çš„ä¸€æœ¬æ›¸ï¼Œå¤§è€Œå…¨ï¼Œå­—å…¸æ›¸ï¼‰
      ã€ŠThe C++ Programming Languageã€‹ï¼ˆC++ä¹‹çˆ¶ Bjarne Stroustrup æ‰€è‘—ï¼‰

é€™ä¸‰æœ¬ï¼Œå…¶å¯¦å„æœ‰å„ªç¼ºé»ï¼Œç¬¬ä¸€æœ¬å„ªé»æ˜¯ç°¡çŸ­ï¼Œåƒ…åƒ…å…©ä¸‰ç™¾é ï¼Œåªæœ‰æœ€çˆ²æ ¸å¿ƒå’Œä¸»å¹¹çš„çŸ¥è­˜é»ã€‚

è€Œå¾Œå…©æœ¬å‰‡éƒ½æ˜¯å¤§è€Œå…¨ï¼Œå°¤å…¶æ˜¯ã€ŠThe C++ Programming Languageã€‹ã€‚

é€™å…©æœ¬å€åˆ¥åœ¨æ–¼ï¼Œä¸€å€‹æ˜¯ C++ å¤§å¸«æ‰€è‘—ï¼Œä¸€æœ¬æ˜¯ C++ ä¹‹çˆ¶æ‰€è‘—ã€‚

ç¶²ä¸Šæœ‰äººèªª ã€ŠC++Primerã€‹æ˜¯ç›®å‰å¸‚é¢ä¸Šå”¯ä¸€ä¸€æœ¬çœŸæ­£çš„å¾å…¥é–€åˆ°ç²¾é€šçš„æ›¸ï¼Œé©åˆåˆå­¸è€…ï¼Œç•¶ä½ å°C++æ¯”è¼ƒç†Ÿæ‚‰ä¹‹å¾Œï¼Œå°±å¯ä»¥æŠŠé€™æœ¬æ›¸ç•¶åšå­—å…¸ï¼Œé‡åˆ°ä¸å¤ªæ¸…æ™°çš„é»å†å›éé ­å»çœ‹
ã€ŠC++ Programming languageã€‹ æ˜¯C++å°ˆå®¶è‡ªå­¸æŒ‡å—ï¼Œé¡§åæ€ç¾©ï¼Œé©åˆæœ‰è¼ƒæ·±åš C++ åŠŸåº•çš„è®€è€…ã€‚

2.2 æ¨è–¦é–±è®€é †åº

æ‰€ä»¥å°åŒ—æ¨è–¦çš„é †åºæ˜¯ï¼š
**ã€ŠAccelerated C++ã€‹->ã€ŠC++ Primerã€‹->ã€ŠThe C++ Programming Languageã€‹**

å°æ–¼é€™ç¨®ä¸Šå‰é å¤§éƒ¨é ­æˆ‘æ¨è–¦çš„é–±è®€æ–¹å¼æ˜¯ï¼Œä»¥ä¸»é¡Œçˆ²åŠƒåˆ†ï¼Œæ¯”å¦‚ C++ Primer å°±æ˜ç¢ºçš„åˆ†çˆ²äº†ï¼š

    C++ åŸºç¤
    C++ æ¨™æº–åº«
    é¡è¨­è¨ˆè€…çš„å·¥å…·
    é«˜ç´šä¸»é¡Œ
    ä¸¦ä¸”è¶Šåˆ°å¾Œé¢ï¼Œä½ è¶Šå¯ä»¥ç›´æ¥ç¿»æ›¸çš„ç›®éŒ„ï¼Œè·³èºç€æ‰¾ä½ æ„Ÿèˆˆè¶£æˆ–è€…èªªé‚„ä¸å¤ªæ¸…æ¥šçš„çŸ¥è­˜é»çœ‹ï¼Œä¸ç”¨å†åƒçœ‹ç¬¬ä¸€æœ¬æ›¸ä¸€æ¨£å¾é ­ç¿»åˆ°å°¾ã€‚

å…¥é–€çµæŸä½ æ‡‰è©²æŒæ¡ä»¥ä¸‹å…§å®¹ï¼š

    åŸºç¤èªè¨€
    é¡èˆ‡é¢å‘å°è±¡
    è¼¸å…¥è¼¸å‡º
    å­—ç¬¦ä¸²è™•ç†ï¼ˆé¡åº«å’Œæ­£å‰‡è¡¨é”å¼ï¼‰
    æŒ‡é‡&å¼•ç”¨
    å®¹å™¨é¡åº«
    æ³›å‹ç®—æ³•

çœ‹ç€åªæœ‰å¹¾å€‹é—œéµå­—ï¼Œå¯¦éš›ä¸Šæ¯å€‹å±•é–‹éƒ½æœ‰å¾ˆå¤šå…§å®¹éœ€è¦å­¸ç¿’ã€‚

å­¸ç¿’éç¨‹ä¸­æŠŠå¾Œé¢çš„æ¯ä¸€å€‹ç·´ç¿’é¡Œéƒ½è‡ªå·±æ•²ä¸€éï¼Œè‡ªå·±å¤šæ€è€ƒå°æ¯”ä¸€ä¸‹ã€‚
å¤šç”¨ä»£ç¢¼å»é©—è­‰è‡ªå·±çš„æƒ³æ³•ï¼Œå°¤å…¶æ˜¯æŒ‡é‡ã€å¼•ç”¨ã€æ§‹é€ ã€ææ§‹é€™äº›åœ°æ–¹ã€‚

---

1. [C++ Core Guidelines](http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines) 2. cpp conference presentation
   [cpp-best-practices/cppbestpractices: Collaborative Collection of C++ Best Practices. This online resource is part of Jason Turner's collection of C++ Best Practices resources. See README.md for more information.](https://github.com/cpp-best-practices/cppbestpractices/tree/master)

> [Learn Contemporary C++ | Concise&Visual Examples | hacking C++](https://hackingcpp.com/index.html)
> my favorite cpp learning web

- [hsutter/cppfront: A personal experimental C++ Syntax 2 -> Syntax 1 compiler](https://github.com/hsutter/cppfront)
  enhanced Cpp

[carbon-language/carbon-lang: Carbon Language's main repository: documents, design, implementation, and related tools. (NOTE: Carbon Language is experimental; see README)](https://github.com/carbon-language/carbon-lang)

- Nvida c++ tutorial
  [federico-busato/Modern-CPP-Programming: Modern C++ Programming Course (C++03/11/14/17/20/23/26)](https://github.com/federico-busato/Modern-CPP-Programming)

[changkun/modern-cpp-tutorial: ğŸ“š Modern C++ Tutorial: C++11/14/17/20 On the Fly | https://changkun.de/modern-cpp/](https://github.com/changkun/modern-cpp-tutorial)

[All C++20 core language features with examples | Oleksandr Kovalâ€™s blog](https://oleksandrkvl.github.io/2021/04/02/cpp-20-overview.html)

---

source: https://matt.might.net/articles/what-cs-majors-should-know/

---

#### ISO C++

C++ is a necessary evil.

But, since it must be taught, it must be taught in full.

In particular, computer science majors should leave with a grasp of even [template meta-programming](http://matt.might.net/articles/c++-template-meta-programming-with-lambda-calculus/).

##### Recommended reading

- [The C++ Programming Language](http://www.amazon.com/gp/product/0201700735/ref=as_li_ss_tl?ie=UTF8&tag=mmamzn06-20&linkCode=as2&camp=217145&creative=399369&creativeASIN=0201700735)![](http://www.assoc-amazon.com/e/ir?t=&l=as2&o=1&a=0201700735&camp=217145&creative=399369) by Stroustrup.
- [C++ Templates: The Complete Guide](http://www.amazon.com/gp/product/0201734842/ref=as_li_ss_tl?ie=UTF8&tag=mmamzn06-20&linkCode=as2&camp=217145&creative=399369&creativeASIN=0201734842)![](http://www.assoc-amazon.com/e/ir?t=&l=as2&o=1&a=0201734842&camp=217145&creative=399369) by Vandevoorde and Josuttis.
- [Programming Pearls](http://www.amazon.com/gp/product/0201657880/ref=as_li_ss_tl?ie=UTF8&camp=1789&creative=390957&creativeASIN=0201657880&linkCode=as2&tag=mmamzn06-20)![](http://www.assoc-amazon.com/e/ir?t=mmamzn06-20&l=as2&o=1&a=0201657880) by Bentley.

standford cpp

cpp Operating system course
cpp cmu database course

os wiki + USOAP

- his cv is pretty good:
  â—¦As engineer: design and developing automated pricing system to support price decisions; making existing systems approx. 300x faster â—¦Involved techniques: Go; C++; Python; Kubernetes; Jenkins; Promethues; Postgres; Redis; AWS; etc.
  [2023 è¯»ä¹¦æ¸…å• - Changkun's Blog](https://changkun.de/blog/posts/2023-reading/)

  æœ€åå°±æ˜¯å·¥ç¨‹ç±»äº†ï¼Œå·¥ç¨‹ç±»çš„ä¹¦ç±å¯¹äºä»Šå¤©çš„æˆ‘åè€Œæ¯”è¾ƒæä¸èµ·å…´è¶£ï¼Œä¸€æ–¹é¢æ˜¯å› ä¸ºåšè¿‡å¤ªå¤šçš„å·¥ç¨‹ç±»çš„é—®é¢˜ï¼Œå¯¹æŠ€æœ¯äº†è§£ç§¯ç´¯äº†ä¸€å®šçš„å¹¿åº¦ï¼Œèƒ½å¤Ÿç›´æ¥çœ‹ç©¿ä¸€ä¸ªæŠ€æœ¯èƒŒååˆ°åº•æ˜¯ä»€ä¹ˆåœ¨é©±åŠ¨ï¼Œåˆ°åº•æ˜¯çº¯ç²¹çš„ç†æ€§è¿˜æ˜¯å¼€å‘äººå‘˜çš„å›ºæ‰§ç­‰ç­‰ã€‚å¦ä¸€æ–¹é¢ï¼Œæˆ‘å¯¹è®¡ç®—æœºæŠ€æœ¯çš„ç†è§£ä»åŸæ¥çš„å¸Œæœ›äº†è§£â€œå¦‚ä½•åšâ€å˜æˆäº†â€œä¸ºä»€ä¹ˆè¦åšâ€ï¼Œå…¶ä¸­ä¸€ä¸ªå¾ˆé‡è¦çš„åŸå› æ˜¯â€œå¦‚ä½•åšâ€è¿™ä¸€é—®é¢˜å¯¹äºç°åœ¨çš„æˆ‘ï¼Œæ›´å¤šçš„æ˜¯è¦ä¹ˆèƒ½ç«‹åˆ»å»ºç«‹èµ·å¦‚ä½•åšçš„è®¤çŸ¥ã€è¦ä¹ˆå°±å°±æ˜¯èƒ½å¤Ÿç«‹åˆ»åˆ¤æ–­è¿™ä¸ªé—®é¢˜æ˜¯å¦å¯è§£ã€‚æ‰€ä»¥å¦‚æœå¦‚ä½•åšå·²ç»ä¸æ˜¯é—®é¢˜ï¼Œæ›´å¤šçš„é—®é¢˜åˆ™æ˜¯åšè¿™ä»¶äº‹æƒ…èƒŒåçš„åŠ¨æœºæ˜¯ä»€ä¹ˆï¼Œå½±å“æœ‰å¤šå¤§ï¼Œæˆ‘åˆ°åº•è¦ä¸è¦åœ¨è¿™ä»¶äº‹æƒ…ä¸ŠèŠ±æ—¶é—´ã€‚

  ***

  > â€œC++ is for people who want to use hardware very well and manage the complexity of doing that through abstractionâ€ Bjarne Stroustrup
  > â€œa language like C++ is not for everybody. It is generated via sharp and effective tool for professional basically and definitely for people who aim at some kind of precisionâ€ Bjarne Stroustrup

  > â€œThe problem with using C++...is that thereâ€™s already a strong tendency in the language to require you to know everything before you can do anythingâ€ Larry Wall, Creator of the Perl language

  > â€œC makes it easy to shoot yourself in the foot; C++ makes it harder, but when you do, it blows your whole leg offâ€ Bjarne Stroustrup, Creator of the C++ language

  aim for hardware and precision
  not for beginners

  Rust (1.0, 2015) has been Stack Overflowâ€™s most loved language for eight years in a row. Rust focuses on performance and zero-abstraction overhead as C++. It is designed to prevent many vulnerabilities that affect C++, especially memory bugs, enforcing constraints at compile type. In addition, it promotes cross-platform compatibility

  ***

  grok:

  The flip side is C++â€™s complexity creeps up. Those segfaults or memory leaks (Googleâ€™s memory safety nemesis) hit when you least expect it. Libraries help, but youâ€™ll still need to grok pointers, manual memory management, and undefined behavior quirks. Itâ€™s forgiving for small projects, brutal for big ones if youâ€™re sloppy.

  ***

  Optimizing the C++ build
  :
  [Is coding in Rust as bad as in C++?](https://quick-lint-js.com/blog/cpp-vs-rust-build-times/)

When working on the original C++ project, quick-lint-js, I already optimized build times using common techniques, such as using PCH, disabling exceptions and RTTI, tweaking build flags, removing unnecessary #includes, moving code out of headers, and externing template instantiations. But there are several C++ compilers and linkers to choose from. Let's compare them and choose the best before I compare C++ with Rust:

> Every second spent trying to understand the language is one not spent understanding the problem

- language complexity

> â€œThe only way to learn a new programming language is by writing programs in itâ€

![books](20250302-modern-cpp/cpp-suggested-books.png)

---

# office reference:

[cppreference.com](https://en.cppreference.com/w/)

[isocpp/CppCoreGuidelines: The C++ Core Guidelines are a set of tried-and-true guidelines, rules, and best practices about coding in C++](https://github.com/isocpp/CppCoreGuidelines/tree/master)
https://www.stroustrup.com/programming.html

---

[Decoded: GNU coreutils â€“ MaiZure's Projects](https://www.maizure.org/projects/decoded-gnu-coreutils/)

---

- [C++ Is An Absolute Blast](https://learncodethehardway.com/blog/31-c-plus-plus-is-an-absolute-blast/)
- [Very Deep Not Boring Beginner Projects](https://learncodethehardway.com/blog/32-very-deep-not-boring-beginner-projects/)

---

created: 2025-03-09T08:19:25 (UTC -04:00)
tags: []
source: https://learncodethehardway.com/blog/28-minimum-educational-c-plus-plus/
author:

---

# Minimum Educational C++

> ## Excerpt
>
> I go through various style guides and attempt to extract the minimum C++ someone can learn to be functional on many code bases, and in your own code.

---

## The Style Guides

With that in mind, I spent the last _few months_ reviewing many different guides, but three came out on top as the most practical and/or commonly referenced:

1.  [Google's C++ Style Guide](https://google.github.io/styleguide/cppguide.html)
2.  [Epic Games C++ Style Guide](https://dev.epicgames.com/documentation/en-us/unreal-engine/epic-cplusplus-coding-standard-for-unreal-engine)
3.  [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)
    [cmu-db/bustub: The BusTub Relational Database Management System (Educational)](https://github.com/cmu-db/bustub)

---

[Read Learn C++ the Hard Way For Free](https://learncodethehardway.com/courses/learn-cpp-the-hard-way/)
[C++ Is An Absolute Blast](https://learncodethehardway.com/blog/31-c-plus-plus-is-an-absolute-blast/)

> [Stroustrup: FAQ](https://www.stroustrup.com/bs_faq.html#generic)

- [0voice/Awesome_c-cpp_Projects: 2025å¹´ æœ€æ–°æ”¶å½•æ•´ç† 500+ ä¸ªé«˜è´¨é‡çš„ C/C++ é¡¹ç›®ï¼ŒåŒ…æ‹¬ä½†ä¸é™äºæ ¸å¿ƒå¼€å‘ã€åŸºç¡€å·¥å…·ã€ç³»ç»Ÿä¸å¹¶å‘ã€ç³»ç»Ÿç¼–ç¨‹ã€å›¾å½¢å¤„ç†ã€ç½‘ç»œé€šä¿¡ã€æ•°æ®å¤„ç†ã€åº”ç”¨æ¡†æ¶ã€å¼€æºå·¥å…·ã€åµŒå…¥å¼å¼€å‘ç­‰å¤šä¸ªé¢†åŸŸã€‚é€‚åˆå­¦ä¹ ã€å‚è€ƒå’Œå®æˆ˜ã€‚](https://github.com/0voice/Awesome_c-cpp_Projects?tab=readme-ov-file) github project reference

- [0voice/cpp_new_features: 2021å¹´æœ€æ–°æ•´ç†ï¼Œ C++ å­¦ä¹ èµ„æ–™ï¼Œå«C++ 11 / 14 / 17 / 20 / 23 æ–°ç‰¹æ€§ã€å…¥é—¨æ•™ç¨‹ã€æ¨èä¹¦ç±ã€ä¼˜è´¨æ–‡ç« ã€å­¦ä¹ ç¬”è®°ã€æ•™å­¦è§†é¢‘ç­‰](https://github.com/0voice/cpp_new_features?tab=readme-ov-file)
- [C++ å‚è€ƒæ‰‹å†Œ](https://c-cpp.com/cpp)

---

# CMU Database

---

created: 2025-03-10T19:07:06 (UTC -04:00)
tags: []
source: https://15445.courses.cs.cmu.edu/fall2024/project0/
author: Andy Pavlo

---

# Project #0 - C++ Primer | CMU 15-445/645 :: Intro to Database Systems (Fall 2024)

> ## Excerpt
>
> Do not post your project on a public Github repository. Overview All the programming projects this semester will be written on the BusTub database management system. This system is written in C++. To make sure that you have the necessary C++ background, you must complete a simple programming assignment to â€¦

---

All the programming projects this semester will be written on the [BusTub](https://github.com/cmu-db/bustub) database management system. This system is written in C++. To make sure that you have the necessary C++ background, you must complete a simple programming assignment to assess your knowledge of basic C++ features. You will not be given a grade for this project, but you **must complete the project with a perfect score** before being allowed to proceed in the course. Any student unable to complete this assignment before the deadline will be asked to drop the course.

All of the code in this programming assignment must be written in C++. The projects will be specifically written for C++17, but we have found that it is generally sufficient to know C++11. If you have not used C++ before, here are some resources to help:

- [15-445 Bootcamp](https://github.com/cmu-db/15445-bootcamp), which contains several small examples to get you familiar with C++11 features.
- [Learncpp](https://www.learncpp.com/) is a useful resource that includes quizzes to test your knowledge.
- [cppreference](https://en.cppreference.com/w/) has more detailed documentation of language internals.
- [A Tour of C++](https://cmu.primo.exlibrisgroup.com/discovery/fulldisplay?docid=alma991019600108604436&context=L&vid=01CMU_INST:01CMU&search_scope=MyInst_and_CI&isFrbr=true&tab=Everything&lang=en) and [Effective Modern C++](https://cmu.primo.exlibrisgroup.com/discovery/fulldisplay?docid=alma991019578256104436&context=L&vid=01CMU_INST:01CMU&search_scope=MyInst_and_CI&tab=Everything&lang=en) are also digitally available from the CMU library.

If you are using VSCode, we recommend you to install [CMake Tools](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools), [C/C++ Extension Pack](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack) and [clangd](https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd). After that, follow this tutorial to learn how to use the visual debugger in VSCode: [Debug a C++ project in VS Code](https://www.youtube.com/watch?v=G9gnSGKYIg4).

If you are using CLion, we recommend you to follow this tutorial: [CLion Debugger Fundamentals](https://www.youtube.com/watch?v=5wGsRdumueU).

If you prefer to use `gdb` for debugging, there are many tutorials available to teach you how to use `gdb`. Here are some that we have found useful:

- [Debugging Under Unix: gdb Tutorial](https://www.cs.cmu.edu/~gilpin/tutorial/)
- [GDB Tutorial: Advanced Debugging Tips For C/C++ Programmers](http://www.techbeamers.com/how-to-use-gdb-top-debugging-tips/)
- [Give me 15 minutes & I'll change your view of GDB](https://www.youtube.com/watch?v=PorfLSr3DDI) \[VIDEO\]

This is a single-person project that will be completed individually (i.e. no groups).

All the programming projects this semester will be written on the [BusTub](https://github.com/cmu-db/bustub) database management system. This system is written in C++. To make sure that you have the necessary C++ background, you must complete a simple programming assignment to assess your knowledge of basic C++ features. You will not be given a grade for this project, but you **must complete the project with a perfect score** before being allowed to proceed in the course. Any student unable to complete this assignment before the deadline will be asked to drop the course.

All of the code in this programming assignment must be written in C++. The projects will be specifically written for C++17, but we have found that it is generally sufficient to know C++11. If you have not used C++ before, here are some resources to help:

- [15-445 Bootcamp](https://github.com/cmu-db/15445-bootcamp), which contains several small examples to get you familiar with C++11 features.
- [Learncpp](https://www.learncpp.com/) is a useful resource that includes quizzes to test your knowledge.
- [cppreference](https://en.cppreference.com/w/) has more detailed documentation of language internals.
- [A Tour of C++](https://cmu.primo.exlibrisgroup.com/discovery/fulldisplay?docid=alma991019600108604436&context=L&vid=01CMU_INST:01CMU&search_scope=MyInst_and_CI&isFrbr=true&tab=Everything&lang=en) and [Effective Modern C++](https://cmu.primo.exlibrisgroup.com/discovery/fulldisplay?docid=alma991019578256104436&context=L&vid=01CMU_INST:01CMU&search_scope=MyInst_and_CI&tab=Everything&lang=en) are also digitally available from the CMU library.

If you are using VSCode, we recommend you to install [CMake Tools](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cmake-tools), [C/C++ Extension Pack](https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools-extension-pack) and [clangd](https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd). After that, follow this tutorial to learn how to use the visual debugger in VSCode: [Debug a C++ project in VS Code](https://www.youtube.com/watch?v=G9gnSGKYIg4).

If you are using CLion, we recommend you to follow this tutorial: [CLion Debugger Fundamentals](https://www.youtube.com/watch?v=5wGsRdumueU).

If you prefer to use `gdb` for debugging, there are many tutorials available to teach you how to use `gdb`. Here are some that we have found useful:

- [Debugging Under Unix: gdb Tutorial](https://www.cs.cmu.edu/~gilpin/tutorial/)
- [GDB Tutorial: Advanced Debugging Tips For C/C++ Programmers](http://www.techbeamers.com/how-to-use-gdb-top-debugging-tips/)
- [Give me 15 minutes & I'll change your view of GDB](https://www.youtube.com/watch?v=PorfLSr3DDI) \[VIDEO\]

This is a single-person project that will be completed individually (i.e. no groups).

---

# My own research of cpp sources:

cmu database course -> cpp bootcamp

Usaco : three books
[Choosing a Language Â· USACO Guide](https://usaco.guide/general/choosing-lang?lang=cpp)

- standford cs106B , CS106L

- CS4414 operating system with cpp 2025-03-27

- modern cpp nvida

- codecraft maybe?

- cmu database

- oswiki (china speedy coding)

- csdiywiki for more advance cpp course

- gaming maybe, using source trail to look high in coding

- [[20250321-essentialist---software-essentialist-2024-7|Essentialist - Software Essentialist 2024-7]]
  for craftsmanship , but typescript like

- cpp datastruce, from pcloud

- cpp pikuma , gaming (godot new c++ gaming framework)

- cpp nanodegreelol

- [Read Learn C++ the Hard Way For Free](https://learncodethehardway.com/courses/learn-cpp-the-hard-way/)
  [C++ Is An Absolute Blast](https://learncodethehardway.com/blog/31-c-plus-plus-is-an-absolute-blast/)

- using repl cling

- maybe learning unit test

---

## another books list recommended 2025-03-31

- from 102-ç¾ä»£C++å¯¦æˆ°30è¬›\_kobo

Alexander A. Stepanov and Daniel E. Rose, From Mathematics to Generic Programming. Addison-Wesley, 2014

Alexander Stepanov æ˜¯ STL ä¹‹çˆ¶ï¼Œé€™æœ¬æ›¸å¯«çš„å»ä¸æ˜¯å…·é«”çš„ç·¨ç¨‹æŠ€ å·§æˆ–æŸå€‹åº«ï¼Œè€Œæ˜¯æŠŠæ³›å‹ç·¨ç¨‹å’ŒæŠ½è±¡ä»£æ•¸æ”¾åœ¨ä¸€èµ·è¨è«–äº†ã€‚èª¬ä¾†æ…š æ„§ï¼Œæˆ‘æ˜¯è®€äº†é€™æœ¬æ›¸ä¹‹å¾Œæ‰å°ç¾£è«–ç¨ç¨æœ‰äº†é»ç†è§£ï¼šä¹‹å‰çœ‹åˆ°çš„ä»‹ç´¹ ææ–™éƒ½éæ–¼æŠ½è±¡ï¼Œæ²’èƒ½ç†è§£ã€‚äº‹å¯¦ä¸Šï¼ŒAlexander ä¹‹å‰é‚„å¯«äº†ä¸€æœ¬åŒ ä¸€é¡Œæã€ä½†ä½¿ç”¨å…¬ç†æ¨å°é¢¨æ ¼çš„ Elements of Programmingï¼ˆè£˜å®—ç‡• è­¯ã€Šç·¨ç¨‹åŸæœ¬ã€‹ï¼‰ï¼Œé‚£æœ¬å°±æ¯”è¼ƒæŠ½è±¡è‰±æ·±ï¼Œå¾å—æ­¡è¿ç¨‹åº¦ä¸Šçœ‹é é ä¸ åŠé€™ä¸€æœ¬ã€‚æˆ‘ä¹Ÿåªæ˜¯è²·äº†æ”¾åœ¨æ›¸æ¶ä¸Šæ²’çœ‹å¤šå°‘é ğŸ˜ã€‚â€‹

é C++ çš„ç¶“å…¸æ›¸ç›® W. Richard Stevens, TCP/IP Illustrated Volume 1: The Protocols. Addison-Wesley, 1994 Gary R. Wright and W. Richard Stevens, TCP/IP Illustrated Volume 2: The Implementation. Addison-Wesley, 1995 W. Richard Stevens, TCP/IP Illustrated Volume 3: TCP for Transactions, HTTP, NNTP and the Unix Domain Protocols. AddisonWesley 1996 ä¸­æ–‡ç‰ˆç¿»è­¯ä¸ä½³ï¼Œä¸æ¨è–¦ã€‚ æ¨è–¦æŒ‡æ•¸ï¼šâ˜…â˜…â˜…â˜…â˜† ä¸æ˜¯æ‰€æœ‰çš„æ›¸éƒ½æ˜¯è¶Šæ–°è¶Šå¥½ï¼Œã€ŠTCP/IP è©³è§£ã€‹å°±æ˜¯å…¶ä¸­ä¸€ä¾‹ã€‚W. Richard Stevens å¯«çš„å·ä¸€æ¯”å¾Œäººè£œå¯«çš„å·ä¸€ç¬¬äºŒç‰ˆè©•åƒ¹æ›´é«˜ï¼Œå°±æ˜¯

---

1. Real-Time C++ by Christopher Kormanyos. - For using C++ in embedded systems.

2. Software Architecture with C++ by Adrian Ostrowski and Piotr Gaczkowski. - Gives the overall picture of how to use C++ plus relevant modern tools as a complete development system.

3. The C++ Programming Language by Bjarne Stroustrup. - The bible/reference with programming techniques for the language.

> Learning C++ is not difficult and don't let the size of the language intimidate you. Survey the different ways of programming in C++ i.e. Imperative/Object-Oriented/Generic/Meta-programming and use them as needed in your project without trying to master everything; that will only happen over time as you gain more experience.

---

- [ä½¿ç”¨cqueryï¼šC++ language server | MaskRay](https://maskray.me/blog/2017-12-03-c++-language-server-cquery)
- [Welcome to Extra Clang Tools's documentation! â€” Extra Clang Tools 21.0.0git documentation](https://clang.llvm.org/extra/)
- clang tools extra

- again [abseil / C++ Developer Guide](https://abseil.io/docs/cpp/) twice ğŸ¤©

[rbaker1776/Intro-to-Modern-Cxx](https://github.com/rbaker1776/Intro-to-Modern-Cxx/tree/main)

---

# TW cpp notes2025-04-27

[Numerical Software Development - Yung-Yu's Notes](https://yyc.solvcon.net/en/latest/nsd/index.html)
[yungyuc/nsd: Numerical Software Development](https://github.com/yungyuc/nsd)

---

- [Quick C++ Benchmarks](https://quick-bench.com/q/jA6xdpp-UhQrteQjAjiIgJwjKbw) + cpp insight + compiler

[Ccache â€” Compiler cache](https://ccache.dev/)

[tehrengruber/Defrustrator: Cling integration in LLDB](https://github.com/tehrengruber/Defrustrator)

[inspector-repl/inspector: A drop-anywhere C++ REPL](https://github.com/inspector-repl/inspector)

and sccache(rust version of ccacehe)

---

```cpp

  // 1. ä¸è¿ç®—ï¼šæœ‰å‡å¿…å‡
  cout << (0 && -1) << endl;
  cout << (0 && 2) << endl;
  cout << (2 && 0) << endl;
  cout << (2 && 2) << endl;
  cout << "---" << endl;
  // 2. æˆ–è¿ç®—ï¼šæœ‰çœŸå¿…çœŸ
  cout << (0 || 0) << endl;
  cout << (0 || 2) << endl;
  cout << (2 || 0) << endl;
  cout << (2 || 2) << endl;
  cout << "---" << endl;
  // 3. éè¿ç®—ï¼šéçœŸå³å‡ï¼Œéå‡å³çœŸ
  cout << !0 << endl;
  cout << !2 << endl;
```

0 != -1 !!!!, only `0&&` will have the case, `-1 ` treat as `1` in T/ F situation

```cpp

/*
     &     æœ‰0å¿…0 -> bit operation
   &&    æœ‰å‡å¿…å‡
*/
```

```cpp
	// 2. å¥‡å¶æ€§
	cout << 5 % 2 << endl;      // % ä¼˜å…ˆçº§é«˜ã€æ•ˆç‡é«˜
	cout << (5 & 1) << endl;    // & ä¼˜å…ˆçº§ä½ã€æ•ˆç‡é«˜

  // the prime number must be (5 & 1) = 1 as bit pattern
  int main() {
    // 1. ä½ä¸è¿ç®—ç¬¦çš„å®šä¹‰
    int a = 0b1010;   // 10
    int b = 0b0110;   // 6
    //      0b0010;   // 2
    cout << (a & b) << endl;
    cout << "--" << endl;

    // 2. å¥‡å¶æ€§
    cout << 5 % 2 << endl;      // % ä¼˜å…ˆçº§é«˜ã€æ•ˆç‡é«˜
    cout << (5 & 1) << endl;    // & ä¼˜å…ˆçº§ä½ã€æ•ˆç‡é«˜
    //   0b101
    //   0b001
    cout << "--" << endl;

    // 3. è·å–ä¸€ä¸ªæ•°äºŒè¿›åˆ¶çš„æœ«5ä½
    int c = 0b1010010101001;  // åäº”ä½ 01001
    cout << (c & 0b11111) << endl;
    cout << "--" << endl;

    // 4. å°†æœ«äº”ä½å½’é›¶
    int d = 0b11111111111111111111111111100000;
    cout << (c & d) << endl; // 0b1010010100000
    cout << "--" << endl;

    // 5. æ¶ˆé™¤æœ«å°¾è¿ç»­çš„1
    int e = 0b101010111111;
    // e+1= 0b101011000000;
    //  & = 0b101010000000;
    cout << (e & (e + 1)) << endl;
    // using bit +1 pattern to erase after 0

    // 6. 2çš„å¹‚åˆ¤å®š
    int f = 0b100000000;
    // f-1= 0b011111111;
    //   &= 0b000000000 = 0;
    (f > 0) && ((f & (f - 1)) == 0);
    // so that the number must be 2**n, e.g. 2.4,8,16 etc
    return 0;
  }

```

however , must adding `() ` for && as the priority is low

31 video

```cpp
/*
      |    ä½æˆ–  ï¼šæœ‰1å³1
	  ||   é€»è¾‘æˆ–ï¼šæœ‰çœŸå³çœŸ
*/
int main() {
	// 1. ä½æˆ–çš„å®šä¹‰
	int a = 0b1010;     // 10
	int b = 0b0110;     // 6
	//  | = 0b1110      // 14
	cout << (a | b) << endl;
	cout << "---" << endl;

	// 2. è®¾ç½®æ ‡è®°ä½
	int c = 0b100111;
	//      0b101111;
	cout << (c | (0b1000)) << endl;
	cout << "---" << endl;

	// 3. ç½®ç©ºæ ‡è®°ä½
	// 0b100111
	int d = 0b000001;
	cout << ((c | d) - d) << endl;
	cout << "---" << endl;

	// 4. ä½ä½è¿ç»­0å˜æˆ1
	int e = 0b1010010000;
	// e-1= 0b1010001111;
	//   -> 0b1010011111;
	int f = 0b1010011111;
	cout << f << endl;
	cout << (e | (e - 1)) << endl;


	return 0;
}

```

    // 3. ç½®ç©ºæ ‡è®°ä½
    // 0b100111
    int d = 0b000001;
    cout << ((c | d) - d) << endl;
    cout << "---" << endl;

- this is useful, without this , u have to manual & the whole correct number

`c|d` making sure both case (1or 0 case ) can be ` - 1` -> empty out the last number

// 4. is useful as well, make all last number to be `111`

```cpp

/*
       ^  å¼‚æˆ– XOR
       only keep the `1 0 ` or `0 1 ` case
*/

  // 2. æ¨™è¨˜ä½å–å
cout << "Why XOR twice restores original:" << endl;
cout << "Step 1: 01000101 ^ 00001000 = 01001101 (flip bit 3)" << endl;
cout << "Step 2: 01001101 ^ 00001000 = 01000101 (flip bit 3 again)" << endl;
cout << "Property: A ^ B ^ B = A (XOR is its own inverse)" << endl;
int main() {
  // 1. ç•°æˆ–çš„å®šç¾©
  int a = 0b1010;
  int b = 0b0110;
  //  ^ = 0b1100;
  cout << (a ^ b) << endl;
  cout << "---" << endl;

  // 2. æ¨™è¨˜ä½å–å
  int c = 0b1000101;
  //      0b0001000
  cout << c << endl;
  cout << (c ^ 0b1000) << endl;
  cout << ((c ^ 0b1000) ^ 0b1000) << endl;
  cout << "---" << endl;

  // 3. è®Šé‡äº¤æ›
  int d = 17;
  int e = 19;
  d = d ^ e;
  e = d ^ e; // = d' ^ e = d ^ e ^ e = d ^ 0 = d
  d = d ^ e; // = d' ^ d = d ^ e ^ d = d ^ d ^ e = 0 ^ e = e
  cout << d << ' ' << e << endl;
  cout << "---" << endl;
  // 3.1 ä»»ä½•æ•¸å’Œ0ç•°æˆ–ï¼Œé‚„æ˜¯å®ƒæœ¬èº«
  // 3.2 å…©å€‹ç›¸åŒçš„æ•¸ç•°æˆ–ï¼Œçµæœç‚º0
  // 3.3 ç•°æˆ–æ»¿è¶³äº¤æ›å¾‹å’Œçµåˆå¾‹
  // ç•°æˆ–ï¼šä¸å¸¶é€²ä½çš„äºŒé€²åˆ¶åŠ æ³•

  // 4. å‡ºç¾å¥‡æ•¸æ¬¡çš„æ•¸

  // 5. åŠ å¯†
  int x = 1314;
  cout << "520" << x << endl;
  int y = (x ^ 3135);
  cout << "520" << y << endl;
  cout << "520" << (y ^ 3135) << endl;

  return 0;
}

```

3, 5 is pretty useful
3.1 ä»»ä½•æ•¸å’Œ0ç•°æˆ–ï¼Œé‚„æ˜¯å®ƒæœ¬èº«
3.2 å…©å€‹ç›¸åŒçš„æ•¸ç•°æˆ–ï¼Œçµæœç‚º0
3.3 ç•°æˆ–æ»¿è¶³äº¤æ›å¾‹å’Œçµåˆå¾‹
ç•°æˆ–ï¼šä¸å¸¶é€²ä½çš„äºŒé€²åˆ¶åŠ æ³•

```cpp
/*
    ~, opposite, flip
*/

int main() {
  // 1. æŒ‰ä½å–åçš„å®šç¾©
  int a = 0b1;
  int b = 0b11111111111111111111111111111110;
  cout << (~a) << endl; // = -2
  cout << b << endl;    // -2
  // **Key insight**: In two's complement, `~n = -(n+1)` because:
  // - `~0 = -1`
  // - `~1 = -2`
  // - `~2 = -3`

  // 0b00000000000000000000000000000000   = 0
  // 0b11111111111111111111111111111111   = -1
  // 0b11111111111111111111111111111110   = -2
  // ...

  int c = 0b0;
  cout << (~c) << endl;

  // 2. æ±‚ç›¸åæ•¸
  int d = 18;
  cout << (~d + 1) << endl; // åŸç¢¼ã€åç¢¼ã€è£œç¢¼ã€ç§»ç¢¼

  return 0;
}

```

```cpp
/*

     x << y   =   x * 2^y

*/
int main() {
  // 1. æ­£æ•¸çš„å·¦ç§»
  int x = 0b11; // 3
  x = (x << 1); // 0b110
  cout << x << endl;
  cout << "---" << endl;
  cout << (x << 4) << endl; // 2 ** 4 =>16 , 9 *16 = 96
  cout << "---" << endl;

  // 2. è² æ•¸çš„å·¦ç§»
  int y = -1;
  y = (y << 1);
  cout << y << endl;
  cout << "---" << endl;

  // 3. å·¦ç§»è² æ•¸ä½
  int z = 64;
  z = (z << (-1)); // ä¸èƒ½é€™éº¼å¯«
  cout << z << endl;
  cout << "---" << endl;

  // 4. å·¦ç§»æº¢å‡º
  int a = 64;
  a = (a << 31);
  cout << a << endl;
  // 64   = 0b1000000
  // <<31 = 0b1...00000000000000000000000000000000

  return 0;
  // so left shift (operator ) must be positive and can' exceel the max bit for
  // the data type
}

```

```cpp

/*
     x >> y    x / 2^y
*/
int main() {
  // 1. æ­£æ•¸çš„å³ç§»
  int a = 0b111; // 7
  a = (a >> 1);  // removed the last 1 , so it is 3
  cout << a << endl;

  // 2. è² æ•¸çš„å³ç§»
  int b = -1;
  cout << (-1 >> 1) << endl;
  // 11111111 11111111 11111111 11111111  =-1
  // 111111111 11111111 11111111 1111111  =-1

  // 3. å»æ‰ä½ k ä½
  int c = 0b10000101;
  cout << (c >> 7) << endl;

  // 4. å–åˆ°ç¬¬ä½kä½çš„å€¼
  int d = 0b101010101;
  cout << ((d >> 4) & 1) << endl;

  return 0;
}

```

negative number will automatically keeping 1 even shifting right,
positive number will not, so it can be used for removing number

3,4 is useful

`(x&1) == (x%m) `

35.video

59.video

seconds to minute -> am / 60
as %60 -> add back to am

```cpp
int main() {
    int t;
    cin >> t;
    while (t--) {
        int n;
        double x;
        double max = 0;
        cin >> n;
        for (int i = 0; i < n; ++i) {
            cin >> x;
            if (x > max) {
                max = x;
            }
        }
        printf("%.2lf\n", max);
    }
    return 0;
}
// For each case output the highest height, the height to two decimal plases;
//
// Sample Input
//
// 2
// 3 170.00 165.00 180.00
// 4 165.00 182.00 172.00 160.00
//
```

---

```cpp
int main() {
	int a = 1;
	a = (5 - 6, 8 + 9, 100 / 7);   // -1, 17, 14
	cout << a << endl;

```

`,` have low priority in cpp, it only consider the rightest value as a , so a == 14

isPrime

```cpp

using namespace std;

//
//   x   æœ‰ä¸€å€‹å› å­å« iï¼Œé‚£éº¼å¿…ç„¶æœ‰å¦ä¸€å€‹å› å­å« x/i
//    i å’Œ x/i å¿…ç„¶æœ‰å€‹å¤§å°é—œä¿‚ï¼Œç„¡è«–å¤§å°é—œä¿‚æ€æ¨£ï¼Œéƒ½èƒ½æ¨å°å‡º i <= æ ¹è™Ÿx
bool isPrime(int x) {
    for (int i = 2; i*i <= x; ++i) {
        if (x % i == 0) {
            return false;
        }
    }
    return true;
}

```

```cpp
  cout << (*&a) << endl;
  cout << "-------" << endl;
  cout << (*(&a)) << endl;
  cout << "-------" << endl;
  cout << (*pa) << endl;
  cout << "-------" << endl;
  cout << (a) << endl;
  // pointer dereference
  // all same

  // 3. * å’Œ &
  // *&a = *(&a) = *pa = a;
  // &*pa = &(*pa) = &a = pa;


```

- `*&a = *(&a) = *pa = a;`
- &*pa = &(*pa) = &a = pa;

**- counting from right hand side damn**

const å’Œ æŒ‡é‡çš„é—œä¿‚
æŒ‡é‡å¸¸é‡
æŒ‡é‡çš„å€¼æ˜¯ä¸€å€‹å¸¸é‡

```cpp

int main() {
    int a = 1;
    int b = 2;
    // æŒ‡é‡å¸¸é‡
    // æŒ‡é‡çš„å€¼æ˜¯ä¸€å€‹å¸¸é‡
    int* const p = &a;
    // p = &b;   éŒ¯èª¤
    *p = 6;
    cout << "a = " << a << endl;

    return 0;
}

```

`   int* const p = &a;`

- you can't change the p address value like `p=&b`, but you can change `*p=6` (deferenced value)

---

å¸¸é‡æŒ‡é‡
æŒ‡å‘å¸¸é‡çš„æŒ‡é‡

```cpp

    const int* p = &a;
```

```cpp
int main() {
    int a = 1;
    int b = 2;
    // å¸¸é‡æŒ‡é‡
    // æŒ‡å‘å¸¸é‡çš„æŒ‡é‡
    const int* p = &a;
    // *p = 6; éŒ¯èª¤
    p = &b;
    cout << "p = " << *p << endl;

    return 0;
}
```

can't change the deferences value `*p = 6` => wrong, but you can change the address of that pointer pointing to

---

both cant' be change pointer

```cpp
/*
æŒ‡é‡å¸¸é‡          tpye* const        æŒ‡é‡å€¼æ˜¯ä¸€å€‹å¸¸é‡                æŒ‡é‡ç„¡æ³•è¢«è³¦å€¼
å¸¸é‡æŒ‡é‡          const type*        æŒ‡å‘å¸¸é‡çš„æŒ‡é‡                  æŒ‡é‡è§£å¼•ç”¨å¾Œç„¡æ³•è¢«è³¦å€¼
å¸¸é‡æŒ‡é‡å¸¸é‡      const type* const  æŒ‡é‡å€¼å’ŒæŒ‡é‡æŒ‡å‘çš„å€¼éƒ½æ˜¯å¸¸é‡    æŒ‡é‡å’Œè§£å¼•ç”¨éƒ½ç„¡æ³•è¢«è³¦å€¼
*/

int main() {
    int a = 1;
    int b = 2;
    // å¸¸é‡æŒ‡é‡å¸¸é‡
    const int* const p = &a;
    // *p = 6;  éŒ¯èª¤
    // p = &b;  éŒ¯èª¤

    return 0;
}
```

this is aka pointer array

```cpp
int main() {
    char a[] = "I";
    char b[] = "love";
    char c[] = "you";

    cout << b << endl; // -> this will print the whole char  as well

    char* p[3];
    p[0] = a;
    p[1] = b;
    p[2] = c;
    for (int i = 0; i < 3; ++i) {
        cout << p[i] << ' ';
    }
    cout << endl;
// output
//  I love you


```

```cpp
    int mat[3][4] = {
        {1,2,3,4},
        {5,6,7,8},
        {9,10,11,12}
    };
    int* pmat[3];
    pmat[0] = mat[0];
    pmat[1] = mat[1];
    pmat[2] = mat[2];
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 4; ++j) {
            cout << *(pmat[i] + j) << ' ';
        }
        cout << endl;
    }

// 1 2 3 4
// 5 6 7 8
// 9 10 11 12

```

array pointer:

```cpp
int main() {
    int(*p)[5];
    int a[4][5] = {
        {4,3,2,1,0},
        {9,8,7,6,5},
        {6,7,8,9,0},
        {5,6,7,8,9}
    };
    p = a;
    cout << p << endl;      // E0    -> EF  ->  F4
    cout << p + 1 << endl;  // F4
    // 20 bit (moved 20 bit)
    // 20 = 4 * 5 = sizeof(int) * 5
    cout << p << ':' << &a[0] << endl; // left : right same address
    cout << p + 1 << ':' << &a[1] << endl; // same address
    return 0;
}
```

- if pointing `a[4][6]` won't work, as size exceed `[5]`
- **it basically point as skipping column**

![](20250302-modern-cpp/2025-09-18-01-02-04.png)

- `p[i] == &(a[i][0])==a[i]` -> storing way

- `int(*p)[5]` -> int pointer that point (\*5) each movement

![](20250302-modern-cpp/2025-09-18-01-11-26.png)

- jumping column
  `&(p[2])` `p+2` -> jumping

![](20250302-modern-cpp/2025-09-18-01-14-11.png)

**- pointer to a pointer -> representing the whole row , damn**

![](20250302-modern-cpp/2025-09-18-01-15-47.png)

```cpp
#include <iostream>
using namespace std;

string getHex(int x) {
    char buff[10];
    sprintf_s(buff, "%X", (x & 0xFFFF));
    return (string)buff;
}

int main() {
    int a[3][4] = {
        {1,2,3,4},
        {5,6,7,8},
        {9,10,11,12}
    };
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 4; ++j) {
            if (j) {
                cout << ",";
            }
            int *p = &a[i][j];
            cout << getHex( (int)p);
        }
        cout << endl;
    }
    // æŒ‡é‡æ•¸çµ„
    int* q[3] = { &a[0][0], &a[1][0], &a[2][0] };
    // æ•¸çµ„æŒ‡é‡
    int(*p)[4];
    p = &a[0];

    cout << "1ã€æŒ‡é‡ + i" << endl;
    // q + i \ p + i
    cout << "æ•¸çµ„æŒ‡é‡" << endl;
    for (int i = 0; i < 3; ++i) {
        string s = getHex((int)(p + i));
        cout << "ç¬¬" << i << "å€‹[4]æ•¸çµ„çš„åœ°å€æ˜¯" << s << endl;
    }
    cout << "æŒ‡é‡æ•¸çµ„ï¼ˆæ²’å•¥ç”¨ï¼‰" << endl;
    for (int i = 0; i < 3; ++i) {
        string s = getHex((int)(q + i));
        cout << "ç¬¬" << i << "å€‹qå…ƒç´ çš„åœ°å€æ˜¯" << s << endl;
    }

    cout << "2ã€*(æŒ‡é‡ + i)" << endl;
    // *(q + i)  \   *(p + i)
    cout << "æ•¸çµ„æŒ‡é‡" << endl;
    for (int i = 0; i < 3; ++i) {
        string s = getHex((int)*(p + i));
        cout << "aæ•¸çµ„çš„ç¬¬" << i << "è¡Œç¬¬ 0 å€‹å…ƒç´ çš„åœ°å€æ˜¯" << s << endl;
    }
    cout << "æŒ‡é‡æ•¸çµ„" << endl;
    for (int i = 0; i < 3; ++i) {
        string s = getHex((int)*(q + i));
        cout << "aæ•¸çµ„çš„ç¬¬" << i << "è¡Œç¬¬ 0 å€‹å…ƒç´ çš„åœ°å€æ˜¯" << s << endl;
    }

    cout << "3ã€*(æŒ‡é‡ + i) + j" << endl;
    for (int i = 0; i < 3; ++i) {
        string s = getHex((int)(*(p + i) + 1) );
        cout << "aæ•¸çµ„çš„ç¬¬" << i << "è¡Œç¬¬ 1 å€‹å…ƒç´ çš„åœ°å€æ˜¯" << s << endl;
    }
    cout << "æŒ‡é‡æ•¸çµ„" << endl;
    for (int i = 0; i < 3; ++i) {
        string s = getHex((int)(*(q + i) + 2) );
        cout << "aæ•¸çµ„çš„ç¬¬" << i << "è¡Œç¬¬ 2 å€‹å…ƒç´ çš„åœ°å€æ˜¯" << s << endl;
    }


    return 0;
}
```

result:

![](20250302-modern-cpp/2025-09-18-01-25-39.png)

![](20250302-modern-cpp/2025-09-18-01-28-28.png)

```cpp
    cout << "3ã€*(æŒ‡é‡ + i) + j" << endl;
    for (int i = 0; i < 3; ++i) {
        string s = getHex((int)(*(p + i) + 1) );
        cout << "aæ•¸çµ„çš„ç¬¬" << i << "è¡Œç¬¬ 1 å€‹å…ƒç´ çš„åœ°å€æ˜¯" << s << endl;
    }
    cout << "æŒ‡é‡æ•¸çµ„" << endl;
    for (int i = 0; i < 3; ++i) {
        string s = getHex((int)(*(q + i) + 2) );
        cout << "aæ•¸çµ„çš„ç¬¬" << i << "è¡Œç¬¬ 2 å€‹å…ƒç´ çš„åœ°å€æ˜¯" << s << endl; // here is + 2 as a `j` example
    }

```

![](20250302-modern-cpp/2025-09-18-01-29-39.png)

---

```cpp
// å‡½æ•¸çš„å€¼å‚³é
void swap(int a, int b) {
  cout << "èª¿ç”¨å‡½æ•¸å¾Œ a çš„åœ°å€ = " << &a << endl;
  cout << "èª¿ç”¨å‡½æ•¸å¾Œ b çš„åœ°å€ = " << &b << endl;
  int temp = a;
  a = b;
  b = temp;
}

// å‡½æ•¸çš„å€å‚³é
void swap(int *a, int *b) {
  cout << "èª¿ç”¨å‡½æ•¸å¾Œ a çš„åœ°å€ = " << a << endl;
  cout << "èª¿ç”¨å‡½æ•¸å¾Œ b çš„åœ°å€ = " << b << endl;
  cout << "----------------" << endl;
  int temp = *a;
  cout << "èª¿ç”¨å‡½æ•¸å¾Œ a çš„å€¼p2 = " << *a << endl;
  cout << "èª¿ç”¨å‡½æ•¸å¾Œ b çš„å€¼ = " << *b << endl;
  cout << "èª¿ç”¨å‡½æ•¸temp çš„å€¼ = " << temp << endl;
  cout << "----------------" << endl;
  *a = *b;
  cout << "èª¿ç”¨å‡½æ•¸å¾Œ a çš„å€¼p3 = " << *a << endl;
  cout << "èª¿ç”¨å‡½æ•¸å¾Œ b çš„å€¼ = " << *b << endl;
  cout << "èª¿ç”¨å‡½æ•¸temp çš„å€¼ = " << temp << endl;
  cout << "----------------" << endl;
  *b = temp;
  cout << "èª¿ç”¨å‡½æ•¸å¾Œ a çš„å€¼p4 = " << *a << endl;
  cout << "èª¿ç”¨å‡½æ•¸å¾Œ b çš„å€¼ = " << *b << endl;
  cout << "èª¿ç”¨å‡½æ•¸temp çš„å€¼ = " << temp << endl;
  cout << "----------------" << endl;
}

int main() {
  int a = 1;
  int b = 2;
  cout << "èª¿ç”¨å‡½æ•¸å‰ a çš„åœ°å€ = " << &a << endl;
  cout << "èª¿ç”¨å‡½æ•¸å‰ b çš„åœ°å€ = " << &b << endl;
  swap(&a, &b);
  cout << "a = " << a << endl;
  cout << "b = " << b << endl;
  cout << "a = " << &a << endl;
  cout << "b = " << &b << endl;
  cout << "----------------" << endl;
  return 0;
}

```

- the address did'nt change , the value did

fuction pointer:

```cpp
#include <iostream>
using namespace std;

// function pointer
double (*ptr)(int a, int b, int c);
void (*ptr1)(int a, int b);

double func(int a, int b, int c) {
  cout << a << "," << b << "," << c << endl;
  return 0.0;
}

void func1(int a, int b) { cout << a << "," << b << endl; }

int main() {
  ptr = func;
  ptr(4, 5, 6);
  // ptr = func1; error becasuse the type of pointer has to match the function as well
  ptr1 = func1;
  ptr1(5, 6);

  return 0;
}
```

- need to match the return type, parameter type

```cpp
// å‡½æ•¸æŒ‡é‡çš„å®šç¾©
void (*fptr1) (int a, int b, int c, float d, char e);
void (*fptr2) (int a, int b, int c, float d, char e);

void func1(int a, int b, int c, float d, char e) {
    cout << "func1" << endl;
}

// å‡½æ•¸æŒ‡é‡çš„é¡å‹å®šç¾©
typedef void (*fptr) (int a, int b, int c, float d, char e);

```

- typedef -> easy way to use function pointer

self define datatype

```cpp
    fptr1 = func1;
    fptr1(1, 2, 3, 4, 5);

    fptr2 = func1;
    fptr2(9, 8, 7, 6, 5);

    fptr fp1 = func1; //-> much easy, typedef void
    //int  x = 6;
    fp1(7, 6, 5, 4, 3);

```

// å‡½æ•¸æŒ‡é‡æ•¸çµ„
// (å‡½æ•¸æŒ‡é‡1, å‡½æ•¸æŒ‡é‡2, ... )

```cpp
typedef void (*fptr) (int a, int b, double c, float d, char e);
typedef void (*fptrs[56]) (int a, int b, double c, float d, char e); // here

void func1(int a, int b, double c, float d, char e) {
    cout << "func1" << endl;
}
void func2(int a, int b, double c, float d, char e) {
    cout << "func2" << endl;
}
void func3(int a, int b, double c, float d, char e) {
    cout << "func3" << endl;
}


int main() {
    //int  a[]= {1 ,2, 3 }; similer to this , except `[]` is put in front , defined first
    fptrs fps = {func1, func2, func3};
    cout << fps[0] << endl;
    cout << fps[1] << endl;
    cout << fps[2] << endl;
    cout << fps[3] << endl;

    fptr fp[] = { func1, func2, func3 }; // easier to understand
    cout << fp[0] << endl;
    cout << fp[1] << endl;
    cout << fp[2] << endl;

    return 0;
}

```

- int a[]= {1 ,2, 3 }; similer to this , except `[]` is put in front , defined first for // å‡½æ•¸æŒ‡é‡æ•¸çµ„

array that contains bunch of function
`typedef void (*fptrs[56]) (int a, int b, double c, float d, char e); // here `

any output exceed the `[max]` will output `0` or `NULL`

`typedef void (*fptr) (int a, int b, double c, float d, char e); `
`   fptr fp[] = { func1, func2, func3 };` -> this way is easier to understand

---

exercise:

```cpp
/*
HDOJ 2081 æ‰‹æ©ŸçŸ­è™Ÿ
https://acm.hdu.edu.cn/showproblem.php?pid=2081

è¼¸å…¥ï¼šè¼¸å…¥ t çµ„æ•¸æ“šï¼Œæ¯çµ„æ•¸æ“šæ˜¯ä¸€å€‹11ä½çš„æ‰‹æ©Ÿè™Ÿ
è¼¸å‡ºï¼šæ¯çµ„æ•¸æ“šè¼¸å‡ºä¸€å€‹6ï¼Œå†è·Ÿä¸Šæ‰‹æ©Ÿè™Ÿçš„æœ«äº”ä½
*/

#include <iostream>
using namespace std;


//             s+6
// s = 123456   78901
int main() {
    int t;
    cin >> t;
    while (t--) {
        char s[12];
        cin >> s;
        cout << '6' << s + 6 << endl;
    }
    return 0;
}
```

- in cpp , cout<<s will print the whole `char s [12]`, `s +6 ` will print the 6 after

```cpp
/*
HDOJ 2099 æ•´é™¤çš„å°¾æ•¸
https://acm.hdu.edu.cn/showproblem.php?pid=2099


*/

#include <iostream>
using namespace std;

// a=200, b=40, è¿”å›å€¼[00, 40, 80], *returnSize = 3
int *calcTail(int a, int b,
              int *returnSize) { // 1ã€è¿”å›å€¼ä»£è¡¨çµæœæ•¸çµ„çš„é¦–åœ°å€ï¼ŒreturnSize
                                 // æ˜¯å¤–éƒ¨å‚³é€²ä¾†çš„ä¸€å€‹åœ°å€
  *returnSize = 0;               // 2ã€å°å¤–éƒ¨å‚³é€²ä¾†çš„æ•¸çµ„å¤§å°ï¼Œé€²è¡Œåˆå§‹åŒ–
  int *ret = new int[100];       // 3ã€ç”³è«‹ä¸€å€‹æ•¸çµ„å…§å­˜ï¼Œæœ€å¤š100å€‹å…ƒç´ 
  for (int i = 0; i < 100; ++i) {
    if ((a * 100 + i) % b ==
        0) { // 4ã€æšèˆ‰æ‰€æœ‰çš„æœ«å…©ä½ï¼Œä¸¦ä¸”åˆ¤æ–·æ˜¯å¦æ•´é™¤ï¼Œå¦‚æœæ•´é™¤å‰‡å¡å…¥çµæœæ•¸çµ„
      ret[(*returnSize)++] = i; // 5ã€(*returnSize)++ ä»£è¡¨å°‡æ•¸çµ„çš„å¤§å° + 1
    }
  }
  return ret;
}

int main() {
  int a, b;
  while (cin >> a >> b) {
    if (!a && !b) {
      break;
    }
    int size;
    int *ret = calcTail(a, b, &size);
    // int* ret = calcTail(a, b, &size); â† passes the address so the function
    // can write into size
    // If size were only declared inside the function, the caller wouldnâ€™t know
    // how many elements to print.
    for (int i = 0; i < size; ++i) {
      if (i) {
        cout << " ";
      }
      if (ret[i] < 10) {
        cout << "0";
        // It ensures each tail is printed as two digits (with a leading zero
        // when needed).
        // So 0..9 are printed as 00..09, matching the required format like 00
        // 40 80. Equivalent modern formatting would be cout << setw(2) <<
        // setfill('0') << ret[i];.
      }
      cout << ret[i];
    }
    cout << endl;
    delete[] ret;
  }
  return 0;
}
```

cpp struct:

```cpp
#include <iostream>
#include <string>
using namespace std;

// 1. çµæ§‹é«”å®šç¾©
// struct çµæ§‹é«”å { çµæ§‹é«”æˆå“¡è®Šé‡åˆ—è¡¨ };
struct Book {
	string name;
	double price;
	int value;
}cpp; // method 3

// 2. å‰µå»ºçµæ§‹é«”

int main() {
	// 2.1
	Book c;
	c.name = "Cèªè¨€ç¨‹åºè¨­è¨ˆ";
	c.price = 39.99;
	c.value = 10;
	cout << c.name << ' ' << c.price << ' ' << c.value << endl;

	// 2.2
	Book py = { "Pythonç·¨ç¨‹", 1999, 10 }; // method 2
	cout << py.name << ' ' << py.price << ' ' << py.value << endl;

	// 2.3
	cpp.name = "C++é›¶åŸºç¤ç·¨ç¨‹";
	cpp.price = 9999999;
	cpp.value = 10000000;
	cout << cpp.name << ' ' << cpp.price << ' ' << cpp.value << endl;

	return 0;
}
```

more :

```cpp
// 1. çµæ§‹é«”å®šç¾©
// struct çµæ§‹é«”å { çµæ§‹é«”æˆå“¡è®Šé‡åˆ—è¡¨ };
struct Book {
	string name;
	double price;
	int value;
}cpp;

int main() {
	// 2. å‰µå»ºä¸€å€‹çµæ§‹é«”æ•¸çµ„
	// Book æ•¸çµ„å[å…ƒç´ å€‹æ•¸] = { {}, {}, {}, ... };
	Book books[3] = {
		{"Cèªè¨€ç¨‹åºè¨­è¨ˆ", 199.99, 7},
		{"Pythoné›¶åŸºç¤", 399.99, 9},
		{"C++é›¶åŸºç¤", 39.99, 1000000}
	};
	books[2].name = "C++å…¥é–€åˆ°å…¥åœŸï¼";
	for (int i = 0; i < 3; ++i) {
		cout << books[i].name << ' ' << books[i].price << ' ' << books[i].value << endl;
	}

	return 0;
}

```

```cpp
// 1. çµæ§‹é«”å®šç¾©
// struct çµæ§‹é«”å { çµæ§‹é«”æˆå“¡è®Šé‡åˆ—è¡¨ };
struct Book {
	string name;
	double price;
	int value;
};

int main() {
	Book b = {"Cèªè¨€", 99.99, 7};
	Book c = b;
	c.name = "Cèªè¨€å…¥é–€";
	Book* pb = &b;
	pb->name = "C++";
	cout << b.name << ' ' << b.price << ' ' << b.value << endl;

	return 0;
}

```

have to use pointer address to modify the value
python will work though just using `Book c = b; c.name == "xxx"`

- nested struct damn:

```cpp
#include <iostream>

using namespace std;

struct Point {
    double x, y;
};

struct Circle {
    Point pt;
    double radius;
};

struct Circles {
    int size;
    Circle c[100];
};


int main() {
    Circle c;
    c.pt.x = 9;
    c.pt.y = 8;
    c.radius = 5;

    Circles cs = {
        2, {
            { {9,8}, 5 },
            { {2,1}, 1 }
        }
    };
    for (int i = 0; i < cs.size; ++i) {
        Circle tmp = cs.c[i];
        cout << "(" << tmp.pt.x << "," << tmp.pt.y << ") " << tmp.radius << endl;
    }

    return 0;
}
```

for three usage of circle, use three `{{{ }}}` to initiate the nested struct

- `  Circle tmp = cs.c[i];` using second level struct tmp to get the value

continue:

```cpp
void printCircle(const Circle *c) {
    // c->pt.x += 1; å¸¸é‡ä¸å¯ä¿®æ”¹
    cout << "(" << c->pt.x << "," << c->pt.y << ") " << c->radius << endl;
}

void moveCircle(Circle *c, int x, int y) {
    //cout << &c << endl;
    c->pt.x += x;
    c->pt.y += y;
}

int main() {
    Circle c = { {9,8}, 5 };
    //cout << &c << endl;
    moveCircle(&c, 1, -2);
    printCircle(&c);
    return 0;
}

```

- the `main()` and `moveC()` have different `& c` if not setting `Circle *c ` c as pointer AND
- have to use pointer `->` `c->pt.x`

- `void printCircle(const Circle *c) { ` is very useful , adding `const` -> read only or
  just printCircle(c) will work as well -> but this way will copy the memory again, not change the og though

```cpp
void printCircle(Circle c) { // copy another one version
  // c->pt.x += 1; å¸¸é‡ä¸å¯ä¿®æ”¹
  cout << "(" << c.pt.x << "," << c.pt.y << ") " << c.radius << endl;
}

```

```cpp
/*
HDOJ 2037 ä»Šå¹´æš‘å‡ä¸AC
https://acm.hdu.edu.cn/showproblem.php?pid=2037

è¼¸å…¥ï¼šåè¦†è¼¸å…¥ä¸€å€‹nï¼Œä»£è¡¨æœ‰nå€‹å€é–“ï¼Œç„¶å¾Œè¼¸å…¥nå€‹å€é–“
è¼¸å‡ºï¼šè¼¸å‡ºé¸æ“‡æœ€å¤šçš„å€é–“æ•¸ï¼Œä¿è­‰æ‰€æœ‰çš„å€é–“éƒ½ä¸é‡ç–Š

*/

#include <iostream>
#include <algorithm>
using namespace std;

struct Interval {
    int s;
    int e;
}I[100];

bool cmp(const Interval& a, const Interval& b) {
    return a.e < b.e;
}

int main() {
    int n;
    while (cin >> n && n) {
        for (int i = 0; i < n; ++i) {
            cin >> I[i].s >> I[i].e;
        }
        sort(I, I + n, cmp);
        int end = -1;
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            if (I[i].s >= end) {
                ans++;
                end = I[i].e;
            }
        }
        cout << ans << endl;

    }
    return 0;
}
```

using greedy algo sort, start with end time of each tv show
**Why this works:**

- Selecting the earliest-ending activity leaves maximum room for future activities
- This ensures we never "waste" time slots unnecessarily

### Algorithm Steps

1. **Sort all activities by end time** (earliest first)
2. **Select the first activity** (earliest ending)
3. **For each remaining activity:**
   - If it starts after the last selected activity ends â†’ select it
   - Otherwise â†’ skip it

**Step 1: Sort by end time**

```
Original:  (1,3) (3,4) (0,7) (3,8) (5,10) (6,12) (2,9) (4,14) (10,15) (8,18) (15,19) (15,20)
Sorted:    (1,3) (3,4) (0,7) (3,8) (5,10) (2,9) (6,12) (4,14) (10,15) (8,18) (15,19) (15,20)
End times:   3     4     7     8    10     9    12    14    15    18    19    20
```

**Step 2: Greedy Selection**

```
Activity 1: (1,3) - end=3
  - start(1) >= end(-1) âœ“ â†’ Select, end = 3

Activity 2: (3,4) - end=4
  - start(3) >= end(3) âœ“ â†’ Select, end = 4

Activity 3: (0,7) - end=7
  - start(0) < end(4) âœ— â†’ Skip

Activity 4: (3,8) - end=8
  - start(3) < end(4) âœ— â†’ Skip

Activity 5: (5,10) - end=10
  - start(5) >= end(4) âœ“ â†’ Select, end = 10
```

### Common Mistakes to Avoid

1. **Sorting by start time instead of end time** - This doesn't guarantee optimality
2. **Sorting by duration** - Longer activities aren't necessarily better
3. **Not checking for conflicts properly** - Must ensure `start >= previous_end`

### Applications

This algorithm applies to many real-world problems:

- **Resource scheduling** (meeting rooms, CPU scheduling)
- **Event planning** (conferences, classes)
- **Job scheduling** (non-preemptive tasks)
- **Memory allocation** (non-overlapping memory blocks)

```cpp
// CORRECT: This prevents overlapping
if (I[i].s >= end) {
// CORRECT: Ensures first activity is considered
int end = -1;

```

```cpp
int end = -1;  // Initialize to impossible value
int ans = 0;   // Counter for selected activities

for (int i = 0; i < n; ++i) {
    if (I[i].s >= end) {  // Check for no overlap
        ans++;             // Increment counter
        end = I[i].e;      // Update end time
    }
}
```

---

## union vs struct

- struct each elements contains its own memory
- union each elements share memory

#### Step 2: Determine Alignment Requirement

The union must be aligned to accommodate the **strictest alignment requirement**:

- `int i`: requires 4-byte alignment
- `double d`: requires 8-byte alignment â† STRICTEST
- `char s[10]`: requires 1-byte alignment

**Result**: Union must be 8-byte aligned

#### Step 3: Calculate Minimum Size

```
Largest member: 10 bytes
Alignment requirement: 8 bytes
Minimum size: max(10, 8) = 10 bytes
```

#### Step 4: Add Padding for Alignment

```
Current size: 10 bytes
Required alignment: 8 bytes
Padding needed: 8 - (10 % 8) = 8 - 2 = 6 bytes
Final size: 10 + 6 = 16 bytes

```

```cpp
#include <iostream>
using namespace std;

struct DataS {
  int i;
  double d;
  char s[10];
};

union DataU {
  int i;      // 4
  double d;   // 8
  char s[10]; // 10
};

/*
1ã€å®šç¾©å’Œä½¿ç”¨åˆ†é–‹
union DataU {
    int i;     // 4
    double d;  // 8
    char s[10];// 10
};
DataU a, b, c;

2ã€å®šç¾©å’Œä½¿ç”¨çµåˆ
union DataU {
    int i;     // 4
    double d;  // 8
    char s[10];// 10
}a, b, c;

3ã€åŒ¿åï¼šä¸æƒ³è®“åˆ¥äººä½¿ç”¨
union {
    int i;     // 4
    double d;  // 8
    char s[10];// 10
}a, b, c;

*/

int main() {
  DataS ds;
  cout << &ds.i << "," << &ds.d << "," << (void *)ds.s << endl;

  DataU du;
  cout << &du.i << "," << &du.d << "," << (void *)du.s << endl;
  cout << sizeof(ds) << endl;
  cout << sizeof(du) << endl;

  return 0;
}
```

```cpp
#include <iostream>
using namespace std;

union DataU {
    int i;      // 4
    double d;   // 8
    char s[7];  // 7
};

int main() {
    cout << sizeof(DataU) << endl;
    DataU du;
    du.s[0] = 255;      // 11111111
    du.s[1] = 1;        // 00000001
    du.s[2] = 0;        // 00000000
    du.s[3] = 0;        // 00000000
    cout << du.i << endl; // 00000000 00000000 00000001 11111111 // output 511
    du.i = 256;
    cout << (int)du.s[0] << (int)du.s[1] << (int)du.s[2] << (int)du.s[3] << endl;

    return 0;
}
```

**What happens:**

- **The same memory is interpreted** as a 4-byte integer
- Little-endian byte order: least significant byte first
- The 4 bytes are: `[255, 1, 0, 0]`

Result: 00000000 00000000 00000001 11111111 = 511

du.i = 256;
cout << (int)du.s[0] << (int)du.s[1] << (int)du.s[2] << (int)du.s[3] << endl;

-> out put 0100 (Big - endian)

however if du.i =255 (int) -> negative -> -1000

---

```cpp
#include <cstring>
#include <iostream>
using namespace std;

struct Info {
  char _name[20];
  int _role;
  union {
    double score;
    char course[20];
  } _sc;

  Info(const char name[20], int role, double s, const char c[20]) {
    strcpy(_name, name);
    _role = role;
    if (s > 0)
      _sc.score = s;
    if (strlen(c) > 0)
      strcpy(_sc.course, c);
  }
};

int main() {
  Info a[4] = {
      Info("å‘¨è€å¸«", 0, -1, "CGaGa"),
      Info("å‘¨è€å¸«", 0, -1, "Python"),
      Info("å‘¨åŒå­¸", 1, 90, ""),
      Info("è‚–åŒå­¸", 1, 88, ""),
  };
  for (int i = 0; i < 4; ++i) {
    if (a[i]._role == 0) {
      cout << a[i]._name << "æ˜¯ä¸€ä½è€å¸«ï¼Œä»–æ˜¯æ•™" << a[i]._sc.course << "çš„"
           << endl;
    } else if (a[i]._role == 1) {
      cout << a[i]._name << "æ˜¯ä¸€ä½å­¸ç”Ÿï¼Œä»–çš„åˆ†æ•¸æ˜¯" << a[i]._sc.score << endl;
    }
  }

  return 0;
}
```

- union make is either xx or xx type, save memory

## 12ã€å†…å­˜ç®¡ç†

// ä»£ç¢¼å€ã€å…¨å±€å€ã€æ£§å€ã€å †å€
ä»£ç¢¼å€:

```cpp

#include <iostream>
using namespace std;

// ä»£ç¢¼å€ã€å…¨å±€å€ã€æ£§å€ã€å †å€

void printMessage() {
    cout << "Hello world!" << endl;
}
int main() {
    printMessage();
    while(1) {}
    return 0;
}

```

å…¨å±€å€:

```cpp
#include <iostream>
using namespace std;

// å…¨å±€å€
// å…¨å±€è®Šé‡ã€å…¨å±€å¸¸é‡ã€éœæ…‹è®Šé‡(inside main)ã€å­—ç¬¦ä¸²å¸¸é‡ (inside main) they are put in the same memory location

int g_a = 1;
int g_b = 2;
const int c_g_a = 3;
const int c_g_b = 4;

int main() {
    cout << "å…¨å±€è®Šé‡g_açš„åœ°å€ï¼š" << &g_a << endl;
    cout << "å…¨å±€è®Šé‡g_bçš„åœ°å€ï¼š" << &g_b << endl;

    int c = 3;
    int d = 4;
    static int e = 5;
    static int f = 6;
    cout << "å±€éƒ¨è®Šé‡cçš„åœ°å€ï¼š" << &c << endl;
    cout << "å±€éƒ¨è®Šé‡dçš„åœ°å€ï¼š" << &d << endl;
    cout << "éœæ…‹è®Šé‡eçš„åœ°å€ï¼š" << &e << endl;
    cout << "éœæ…‹è®Šé‡fçš„åœ°å€ï¼š" << &f << endl;

    cout << "å­—ç¬¦ä¸²å¸¸é‡çš„åœ°å€ï¼š" << &"è‹±é›„å“ªè£å‡ºä¾†" << endl;

    const int g = 7;
    const int h = 8;
    cout << "å±€éƒ¨å¸¸é‡gçš„åœ°å€ï¼š" << &g << endl;
    cout << "å±€éƒ¨å¸¸é‡hçš„åœ°å€ï¼š" << &h << endl;

    cout << "å…¨å±€å¸¸é‡c_g_açš„åœ°å€ï¼š" << &c_g_a << endl;
    cout << "å…¨å±€å¸¸é‡c_g_bçš„åœ°å€ï¼š" << &c_g_b << endl;

    return 0;
}
```

å…¨å±€å€
å…¨å±€è®Šé‡ã€å…¨å±€å¸¸é‡ã€éœæ…‹staticè®Šé‡(inside main)ã€å­—ç¬¦ä¸²å¸¸é‡ (inside main) they are put in the same memory location

inside main() variable:

stack memory

```cpp
#include <iostream>
using namespace std;

//stack memory

char* func() {
    char c[20] = "è‹±é›„å“ªè£å‡ºä¾†";
    return c;
}

void test(int a, int b) {
    int c, d;
    cout << "å½¢å¼åƒæ•¸açš„åœ°å€ï¼š" << &a << endl;
    cout << "å½¢å¼åƒæ•¸bçš„åœ°å€ï¼š" << &b << endl;
    cout << "å±€éƒ¨è®Šé‡cçš„åœ°å€ï¼š" << &c << endl;
    cout << "å±€éƒ¨è®Šé‡dçš„åœ°å€ï¼š" << &d << endl;
  // stack memory , close address
}


int main() {
    cout << func() << endl;
    test(5, 6);
    return 0;
}
```

the string memory of `c[20]` store in heap memory , stack memory will erase that memory after return c;, so this func()
won't work

Memory Management Best Practices

### DO's

1. **Use stack** for local variables and temporary data
2. **Use heap** for data that needs to persist beyond function scope
3. **Always free** heap memory after use
4. **Use RAII** (Resource Acquisition Is Initialization)
5. **Use smart pointers** for automatic memory management

### DON'Ts

1. **Never return** addresses of local variables
2. **Never use** freed memory
3. **Never forget** to free heap memory
4. **Never assume** memory layout
5. **Never use** uninitialized pointers

### Common Memory Errors

#### 1. Dangling Pointer

```cpp
char* func() {
    char c[20] = "hello";
    return c;  // DANGEROUS!
}
```

#### 2. Memory Leak

```cpp
char* func() {
    char* c = new char[20];
    return c;  // OK, but must free later
}
// If not freed: MEMORY LEAK
```

#### 3. Double Free

```cpp
char* c = new char[20];
delete[] c;
delete[] c;  // ERROR: Double free
```

#### 4. Use After Free

```cpp
char* c = new char[20];
delete[] c;
strcpy(c, "hello");  // ERROR: Use after free
```

### Modern C++ Solutions

#### Smart Pointers

```cpp
##include <memory>

std::unique_ptr<char[]> func() {
    auto c = std::make_unique<char[]>(20);
    strcpy(c.get(), "è‹±é›„å“ªè£å‡ºä¾†");
    return c;  // Automatic cleanup
}
```

#### RAII Classes

```cpp
class StringBuffer {
    char* data;
    size_t size;
public:
    StringBuffer(size_t s) : size(s) {
        data = new char[size];
    }
    ~StringBuffer() {
        delete[] data;  // Automatic cleanup
    }
    // ... other methods
};
```

---

heap memory:

// malloc free
// new delete

```cpp
#include <iostream>
using namespace std;

// malloc free (c) -> function
// new delete (cpp) -> +*/ -> math operation

int* getV(int v) {
    int* a = new int(v);  // int *a æ˜¯ä¸€å€‹æ£§ stackä¸Šçš„è®Šé‡
    cout << a << endl;    // *a ä¹Ÿå°±æ˜¯ a è§£å¼•ç”¨ä»¥å¾Œå¾—åˆ°çš„å€¼ï¼Œæ˜¯å­˜å„²åœ¨å †ä¸Šé¢çš„
    return a;             // å‡½æ•¸è¿”å›çš„æ™‚å€™ï¼Œé›–ç„¶æ£§ä¸Šçš„è®Šé‡ a è¢«æ“ä½œç³»çµ±é‡‹æ”¾äº†ï¼Œä½†æ˜¯ a æŒ‡å‘çš„å…§å­˜ï¼Œé‚„æ˜¯å­˜åœ¨çš„
}

int main() {
    int *p = getV(1314);
    cout << *p << endl;   // æ‰€ä»¥ï¼Œé€™è£é‚„æ˜¯å¯ä»¥è§£å¼•ç”¨ï¼Œå¾—åˆ°å †ä¸Šçš„æ•¸æ“šçš„
    cout << p << endl;
    return 0;
}
```

so usig new () for creating heap memory , even the stack variable is erase after the return , but it successfully pass
the task to heap memory and then disappear

### Code Analysis

```cpp
int *getV(int v) {
    int *a = new int(v);  // Stack: pointer 'a', Heap: value 'v'
    cout << a << endl;    // Prints heap address
    return a;             // Returns heap address (safe!)
}
```

### Memory Creation Timeline

#### 1. **Stack Memory Creation**

- **When**: Function `getV()` is called
- **What**: Local pointer variable `a` is created on stack
- **Lifecycle**: Exists only during function execution
- **Cleanup**: Automatically destroyed when function returns

#### 2. **Heap Memory Creation**

- **When**: `new int(v)` is executed
- **What**: Integer value `1314` is allocated on heap
- **Lifecycle**: Exists until manually freed with `delete`
- **Cleanup**: Must be manually managed by programmer

### Visual Memory Layout

```
During getV(1314) execution:

STACK MEMORY:
Address: 0x7ffdc7f870e0
         |------|
         |  a   |  â† Pointer variable (stack)
         |0x6000|  â† Points to heap address
         |------|

HEAP MEMORY:
Address: 0x600000000000
         |------|
         | 1314 |  â† Actual value (heap)
         |------|
```

### After Function Returns

```
STACK MEMORY:
Address: 0x7ffdc7f870e0
         |------|
         | ???  |  â† Variable 'a' destroyed
         |------|

HEAP MEMORY:
Address: 0x600000000000
         |------|
         | 1314 |  â† Value still exists!
         |------|
```

### Why Heap Memory Persists

#### Key Points:

1. **Stack variable `a`**: Destroyed when function returns
2. **Heap value `1314`**: Remains until `delete` is called
3. **Returned address**: Points to persistent heap memory
4. **Safe dereference**: `*p` works because heap memory still exists

### Memory Management Rules

#### Stack Memory:

- âœ… **Automatic allocation/deallocation**
- âœ… **Fast access**
- âŒ **Function-scoped only**
- âŒ **Cannot return addresses**

#### Heap Memory:

- âœ… **Persists beyond function scope**
- âœ… **Can return addresses safely**
- âŒ **Manual management required**
- âŒ **Must call `delete` to free**

### Complete Example Flow

```cpp
int main() {
    int *p = getV(1314);    // p gets heap address
    cout << *p << endl;     // âœ… Works: heap memory exists
    cout << "what" << endl;
    cout << p << endl;      // âœ… Works: prints heap address
    // delete p;            // âŒ Missing: memory leak!
    return 0;
}
```

### Key Takeaways

1. **Stack variables**: Destroyed when function returns
2. **Heap memory**: Persists until manually freed
3. **Returning heap addresses**: Safe and valid
4. **Returning stack addresses**: Dangerous (dangling pointer)
5. **Memory leak**: Forgot to call `delete p` in main()

### Memory Leak Fix

```cpp
int main() {
    int *p = getV(1314);
    cout << *p << endl;
    cout << "what" << endl;
    cout << p << endl;
    delete p;  // âœ… Free heap memory
    return 0;
}
```

**Summary**: Stack pointer `a` is destroyed, but heap value `1314` persists, making the returned address safe to dereference.

---

new , delete (controlling heap memory)

```cpp
// new ÂºÃ delete

#include <iostream>
using namespace std;

int main() {
  // int *ptr1 = new int; // non initiate example
  // cout << *ptr1 << endl;
  int *ptr = new int(1314);
  *ptr = 520;
  cout << *ptr << endl;

  delete ptr;
  ptr = NULL; // using this for late people using if status to decide use it or
              // not
  return 0;
}
```

array new , and delete

```cpp
#include <iostream>
using namespace std;

int* getGapList(int *arr, int size) {
    int *p = new int[size - 1];
    // int a[size-1];  return a;  a æ˜¯æ£§ä¸Šçš„å…§å­˜ï¼Œä¸èƒ½ä½œç‚ºè¿”å›å€¼è¿”å›
    for (int i = 0; i < size - 1; ++i) {
        p[i] = arr[i + 1] - arr[i];
    }
    return p;
}

int main() {
    int arr[] = { 1,5,6,4,4,3,3,2,1,9 };
    int* p = getGapList(arr, 10);
    for (int i = 0; i < 9; ++i) {
        cout << p[i] << " ";
    }
    cout << endl;
    delete[] p;
    p = NULL;

    return 0;
}
```

---

## å¼•ç”¨ï¼šçµ¦è®Šé‡å–ä¸€å€‹åˆ¥å (reference) easy way of pointer

- stl using a lot of this, just a easier way to use pointer

```cpp
#include <iostream>
using namespace std;

int main(int argc, char *argv[]) {
  int a = 1314;
  int *b = &a;
  *b = 520;
  std::cout << "a  " << a << endl;
  std::cout << "b  " << *b << endl;
  return 0;
}

#include <iostream>
using namespace std;

int main(int argc, char *argv[]) {
  int a = 1314;
  int &b = a;
  b = 520;
  std::cout << "a  " << a << endl;
  return 0;
}

```

- they are same, once using pointer and address, one just directly setting address as a
  but less code, only one `&` replacing ` 3 * and 1 &` pointer way

```cpp
#include <iostream>
using namespace std;

// æŒ‡é‡ï¼šæ‰€ä»¥æ„›æœƒæ¶ˆå¤±ï¼Œå°å˜›ï¼Ÿ
// å¼•ç”¨ï¼šçµ¦è®Šé‡å–ä¸€å€‹åˆ¥å
// &
// æ•¸æ“šé¡å‹& è®Šé‡å = è®Šé‡;

void test() {
    int a_very_very_very_very_very_very_very_long_array[8] = { 1, 1 };
    for (int i = 2; i < 8; ++i) {
        a_very_very_very_very_very_very_very_long_array[i] = a_very_very_very_very_very_very_very_long_array[i - 1] * a_very_very_very_very_very_very_very_long_array[i - 1] + a_very_very_very_very_very_very_very_long_array[i - 2] * a_very_very_very_very_very_very_very_long_array[i - 2];
    }
    for (int i = 0; i < 8; ++i) {
        cout << a_very_very_very_very_very_very_very_long_array[i] << " "; // just print
    }
    cout << endl;
    for (int i = 2; i < 8; ++i) {
        a_very_very_very_very_very_very_very_long_array[i] = 0; // clean that up for next
    }

    for (int i = 2; i < 8; ++i) {
        int& pre1 = a_very_very_very_very_very_very_very_long_array[i - 1];
        int& pre2 = a_very_very_very_very_very_very_very_long_array[i - 2];
        int& now = a_very_very_very_very_very_very_very_long_array[i];
        now = pre1 * pre1 + pre2 * pre2;
    }
    for (int i = 0; i < 8; ++i) {
        cout << a_very_very_very_very_very_very_very_long_array[i] << " ";
    }
    cout << endl;
}

int main() {
    /*
    int a = 1314;
    int& b = a;
    b = 520;
    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
    */
    int a = 1314;
    int* b = &a;
    *b = 520;
    cout << "a = " << a << endl;
    cout << "b = " << *b << endl;

    test();

    return 0;
}
```

---

cpp reference rules , **difference btw pointer** ,

**// 1ã€å¿…é ˆåˆå§‹åŒ–
// 2ã€åˆå§‹åŒ–ä»¥å¾Œç„¡æ³•ä¿®æ”¹**

```cpp
#include <iostream>
using namespace std;

// 1ã€å¿…é ˆåˆå§‹åŒ–
// 2ã€åˆå§‹åŒ–ä»¥å¾Œç„¡æ³•ä¿®æ”¹

int main() {
    // int& a; éŒ¯èª¤å¯«æ³•
    int a = 3, c = 6;
    int& b = a;
    b = c;  // b = 6;
    cout << a << b << c << endl;
    return 0;
}

//output is 666 , it changed all the variable into one
```

- cpp reference is using pointer const from assembly

```cpp
#include <iostream>
using namespace std;

// å¼•ç”¨    è§£å¼•ç”¨

int main() {
  int a = 520;
  // int &b = a; // 00007FF7D5C81865  lea         rax,[a]
  //  00007FF7D5C81869  mov         qword ptr[b], rax

  // b = 1314; // 00007FF7D5C8186D  mov         rax,qword ptr [b]
  //  00007FF7D5C81871  mov         dword ptr[rax], 522h

  int *const b = &a; // 00007FF77E9B1865  lea         rax,[a]
  //                    // 00007FF77E9B1869  mov         qword ptr[b], rax
  *b = 1314; // 00007FF77E9B186D  mov         rax, qword ptr[b]
  // 00007FF77E9B1871  mov         dword ptr[rax], 522h

  return 0;
}

```

#### Constant Pointer (C):

```cpp
int *const b = &a;  // Constant pointer to 'a'
*b = 1314;         // Changes 'a' through pointer
```

### What `const` Means Here

#### `int *const b`:

- **`b` is constant** - cannot be reassigned
- **`*b` is mutable** - the value it points to can be changed

#### Examples:

```cpp
int a = 520;
int c = 100;
int *const b = &a;

// âœ… Valid operations:
*b = 1314;        // Change the value 'b' points to
cout << *b;       // Read the value 'b' points to

// âŒ Invalid operations:
b = &c;           // ERROR: Cannot reassign constant pointer
b = nullptr;      // ERROR: Cannot reassign constant pointer
```

```cpp
#include <iostream>
using namespace std;

int countAndSum(int arr[], int size, int target, int& count) {
    int sum = 0;
    cout << &count << endl;
    for (int i = 0; i < size; ++i) {
        if (arr[i] == target) {
            count++;
            sum += arr[i];
        }
    }
    return sum;
}

struct S {
    int a, b, c, d, e, f, g;
};

void printS(S& s) {
    cout << &s << endl;
    cout << s.a << s.b << s.c << s.d << s.e << s.f << s.g << endl;
}

int main() {
    int arr[] = { 1,2,3,2,4,5,6,4,3,2 };  // 10
    int c = 0;
    cout << &c << endl;
    int sum = countAndSum(arr, 10, 2, c);
    cout << sum << " " << c << endl;

    S s = { 1,2,3,4,5,6,7 };
    cout << &s << endl;
    printS(s);

    return 0;
}
```

just a study of memory btw reference , and c pointer dereference

---

117_13-5å¼•ç”¨ä½œä¸ºå‡½æ•°è¿”å›å€¼

```cpp
#include <iostream>
using namespace std;

int& getArrayValue(int arr[], int index) {
    return arr[index];
}

int main() {
    int a[] = { 8,7,6,5,4,3 };
    cout << getArrayValue(a, 3) << endl;

    getArrayValue(a, 3) = 999;   // a[3] = 999;

    cout << getArrayValue(a, 3) << endl;

    return 0;
}
```

- so that you don't need to write anoter setArrayvalue but just change the address

---

118_13-6å¸¸é‡å¼•ç”¨

```cpp
#include <iostream>
#include <vector>
using namespace std;

struct S {
    int a, b, c, d, e, f;
};

void printS(const S& s) {
    // s.b = 520;
    cout << s.a << s.b << s.c << s.d << s.e << s.f << endl;
}

int main() {
    int a;
    const int& b = a;
    // å¼•ç”¨ = æŒ‡é‡å¸¸é‡
    // å¸¸é‡å¼•ç”¨ = å¸¸é‡æŒ‡é‡å¸¸é‡
    S s = { 1,2,3,4,5,6 };
    printS(s);

    vector<int> a;

    return 0;
}
```

```cpp

void printS(const S& s) {
}

//ban people changing the value of that deference value
```

---

119_13-7æŒ‡é’ˆå¼•ç”¨ done

`*&`

```cpp
#include <iostream>
using namespace std;

// *&

void allocMemory1(char *ptr, int bytes) {
  ptr = new char[bytes];
  cout << "ptr çš„åœ°å€ï¼š" << &ptr << endl;
}

void test1() {
  char *p = NULL;
  allocMemory1(p, 5);
  cout << (void *)p << endl;
  cout << "  p çš„åœ°å€ï¼š" << &p << endl;
}

void allocMemory2(char *&ptr, int bytes) {
  ptr = new char[bytes];
  cout << "ptr çš„åœ°å€ï¼š" << &ptr << endl;
}

void test2() {
  char *p = NULL;
  allocMemory2(p, 5);
  cout << (void *)p << endl;
  cout << "  p çš„åœ°å€ï¼š" << &p << endl;
}

int main() {
  // test1();
  test2();
  return 0;
}
```

- using `void allocMemory2(char *&ptr, int bytes) { ` `*& tr`
  to make `ptr = new char[bytes];` to have same heap memory address

---

```cpp
#include <iostream>
using namespace std;

/*
è¨ªå•æ¬Šé™
å…¬å…±æ¬Šé™   public         é¡å…§å¯ä»¥è¨ªå•ï¼Œé¡å¤–ä¹Ÿå¯ä»¥è¨ªå•
ä¿è­·æ¬Šé™   protected      é¡å…§å¯ä»¥è¨ªå•ï¼Œé¡å¤–ä¸å¯ä»¥è¨ªå•    å­é¡å¯ä»¥è¨ªå•
ç§æœ‰æ¬Šé™   private        é¡å…§å¯ä»¥è¨ªå•ï¼Œé¡å¤–ä¸å¯ä»¥è¨ªå•    å­é¡ä¸å¯ä»¥è¨ªå•

B -> A

A  çˆ¶é¡ã€åŸºé¡       åå­—ã€æˆ¿å­ã€æ”¯ä»˜å¯†ç¢¼
B  å­é¡ã€æ´¾ç”Ÿé¡     å…¬æœ‰ã€ä¿è­·ã€ç§æœ‰

*/


class People {
    // å…¬æœ‰æ¬Šé™
public:
    int m_Id;

    // ä¿è­·æ¬Šé™
protected:
    int m_HouseId;

    // ç§æœ‰æ¬Šé™
private:
    int m_PayPass;

public:
    void work() {
        // æ‰€æœ‰æˆå“¡è®Šé‡ï¼Œé¡å…§å‡å¯ä»¥è¨ªå•
        m_Id = 1;
        m_HouseId = 2;
        m_PayPass = 1314;
    }
private:
    void work1() {
        // æ‰€æœ‰æˆå“¡è®Šé‡ï¼Œé¡å…§å‡å¯ä»¥è¨ªå•
        m_Id = 1;
        m_HouseId = 2;
        m_PayPass = 1314;
    }

};


class Son : public People {
    void func() {
        m_Id = 1;
        m_HouseId = 4;    // ä¿è­·æˆå“¡ï¼Œå­é¡å¯ä»¥è¨ªå•
        // m_PayPass = 123;  // ç§æœ‰æˆå“¡ï¼Œå­é¡ç„¡æ³•è¨ªå•
    }
};

int main() {
    // å¯¦ä¾‹åŒ–
    People p;
    p.m_Id = 1;       // å…¬æœ‰æˆå“¡ï¼Œé¡å¤–å¯ä»¥è¨ªå•
    //p.m_HouseId = 5;  // ä¿è­·æˆå“¡ï¼Œé¡å¤–ä¸å¯ä»¥è¨ªå•
    //p.m_PayPass = 10; // ç§æœ‰æˆå“¡ï¼Œé¡å¤–ä¸å¯ä»¥è¨ªå•
    p.work();
    // p.work1();        // ç§æœ‰æˆå“¡å‡½æ•¸ï¼Œé¡å¤–ä¸å¯è¨ªå•
    return 0;
}
```

---

```cpp
#include <iostream>
using namespace std;

/*
struct && class


struct é»˜èªæ˜¯å…¬å…±çš„
class  é»˜èªæ˜¯ç§æœ‰çš„
*/

class C {
    int m_a;
};

struct S {
    int m_a;

    void func() {
        m_a = 666;
    }
};

int main() {
    C c;
    S s;
    // c.m_a;      // ç§æœ‰çš„
    s.m_a = 4;  // å…¬æœ‰çš„
    s.func();
    cout << s.m_a << endl;

    return 0;
}
```

- cpp struct ( could define fn) vs c struct (couldn't)

---

```cpp
#include <iostream>
#include <string>
using namespace std;

// æ¥å£ã€æ–¹æ³•ã€å‡½æ•¸ æ˜¯åŒä¸€å€‹æ¦‚å¿µ
// 1ã€å¯ä»¥æ§åˆ¶è®€å¯«æ¬Šé™
// 2ã€å¯ä»¥æª¢æ¸¬æ•¸æ“šçš„æœ‰æ•ˆæ€§

class Hero {
public:
    void SetName(string name) {
        m_Name = name;
    }
    string GetName() {
        return m_Name;
    }

    int GetSkillCount() {
        return m_SkillCount;
    }

    void SetSpeed(int speed) {
        if (speed < 100 || speed > 500) {
            cout << "é€Ÿåº¦è¨­ç½®ä¸åˆæ³•" << endl;
            return;
        }
        m_Speed = speed;
    }

private:
    string   m_Name;            // å¯è®€ï¼Œå¯å¯«
    int      m_SkillCount = 4;  // åªè®€
    int      m_Speed;           // åªå¯«
};

int main() {
    Hero h;
    /*
        h.m_Name = "123";
        h.m_SkillCount = 4;
        h.m_Speed = 10;
    */
    h.SetName("åŠè–");
    cout << "è‹±é›„çš„åå­—å«ï¼š" << h.GetName() << endl;
    cout << "è‹±é›„çš„æŠ€èƒ½æ•¸æ˜¯ï¼š" << h.GetSkillCount() << endl;
    h.SetSpeed(666);


    return 0;
}
```

2ã€å¯ä»¥æª¢æ¸¬æ•¸æ“šçš„æœ‰æ•ˆæ€§
set -> one time to let later set use same fn

---

```cpp
#include <iostream>
#include <string>
using namespace std;

/*
æ§‹é€ å‡½æ•¸éœ€è¦æ³¨æ„çš„é»

1ã€å‡½æ•¸åç¨±å’Œé¡åä¿æŒä¸€è‡´
2ã€è¿”å›å€¼é¡å‹ ä¸éœ€è¦å¯«
3ã€æ§‹é€ å‡½æ•¸å¯ä»¥æœ‰åƒæ•¸
*/
class Hero {
public:
  // é»˜èªæ§‹é€ å‡½æ•¸
  Hero() {
    m_Name = "";
    m_SkillCount = 4;
    m_Speed = 100;
    cout << "é»˜èªæ§‹é€ å‡½æ•¸ï¼šHero æ§‹é€ å®Œç•¢ï¼" << endl;
  }
  // æœ‰åƒæ§‹é€ å‡½æ•¸1
  Hero(string name) {
    m_Name = name;
    m_SkillCount = 4;
    m_Speed = 100;
    cout << "æœ‰åƒæ§‹é€ å‡½æ•¸1ï¼šHero æ§‹é€ å®Œç•¢ï¼" << endl;
  }
  // æœ‰åƒæ§‹é€ å‡½æ•¸2
  Hero(string name, int skillCount) {
    m_Name = name;
    m_SkillCount = skillCount;
    m_Speed = 100;
    cout << "æœ‰åƒæ§‹é€ å‡½æ•¸2ï¼šHero æ§‹é€ å®Œç•¢ï¼" << endl;
  }

private:
  string m_Name;
  int m_SkillCount;
  int m_Speed;
};

int main() {
  Hero h1;
  Hero h2("åŠè–");
  std::cout << "test";
  Hero h3(); // å‡½æ•¸è²æ˜    int main();   ã€   int work(); not gonna build (function declaration)
  std::cout << "test2" << endl;
  Hero h4{};
  std::cout << "test3" << endl;
  Hero h5 = Hero("åŠè–");
  Hero h6{"çŒ´å­", 4};

  return 0;
}
```

`Hero h5 = Hero("åŠè–");`

` Hero h3(); // å‡½æ•¸è²æ˜    int main();   ã€   int work(); not gonna build (function declaration)`

1ã€å‡½æ•¸åç¨±å’Œé¡åä¿æŒä¸€è‡´
2ã€è¿”å›å€¼é¡å‹ ä¸éœ€è¦å¯«
3ã€æ§‹é€ å‡½æ•¸å¯ä»¥æœ‰åƒæ•¸

---

## ææ§‹å‡½æ•¸æ³¨æ„é» Destructor

```cpp
#include <iostream>
using namespace std;

/*
ææ§‹å‡½æ•¸æ³¨æ„é» Destructor

1ã€å‡½æ•¸åç¨±å’Œé¡åä¸€è‡´ï¼Œä¸¦ä¸”åœ¨æœ€å‰é¢åŠ ä¸Šä¸€å€‹ ~ æ³¢æµªè™Ÿ
2ã€å‡½æ•¸è¿”å›å€¼ä¸éœ€è¦å¯«
3ã€ä¸èƒ½æœ‰åƒæ•¸

*/
class Hero {
public:
  // æ§‹é€ å‡½æ•¸
  Hero() { cout << "Hero é»˜èªæ§‹é€ å‡½æ•¸èª¿ç”¨å®Œç•¢ï¼" << endl; }
  // ææ§‹å‡½æ•¸
  ~Hero() { cout << "Hero ææ§‹å‡½æ•¸èª¿ç”¨å®Œç•¢ï¼" << endl; }
};

void test() { Hero h; }

int main() {
  test();
  Hero h;
  int a;
  cin >> a;
  // it will wait until the program really finish (after cin)
  return 0;
}
```

- it will wait until the program really finish (after cin) , no ~hero() immediatly

---

æ‹·è²æ§‹é€ å‡½æ•¸çš„å®šç¾©

```cpp
#include <iostream>
using namespace std;


/*
æ‹·è²æ§‹é€ å‡½æ•¸çš„å®šç¾©
é¡å(const é¡å‹& è®Šé‡å) {}

*/
class Hero {
public:
    // é»˜èªæ§‹é€ å‡½æ•¸
    Hero() {
        m_Hp = 100;
        cout << "Hero é»˜èªæ§‹é€ å‡½æ•¸èª¿ç”¨å®Œç•¢ï¼" << endl;
    }

    // æœ‰åƒæ§‹é€ å‡½æ•¸
    Hero(int hp) {
        m_Hp = hp;
        cout << "Hero æœ‰åƒæ§‹é€ å‡½æ•¸èª¿ç”¨å®Œç•¢ï¼" << endl;
    }

    Hero(const Hero& h) {
        m_Hp = h.m_Hp;
        cout << "Hero æ‹·è²æ§‹é€ å‡½æ•¸èª¿ç”¨å®Œç•¢ï¼" << endl;
    }

    // ææ§‹å‡½æ•¸
    ~Hero() {
        cout << "Hero ææ§‹å‡½æ•¸èª¿ç”¨å®Œç•¢ï¼" << endl;
    }

private:
    int   m_Hp;
};


/*
æ‹·è²æ§‹é€ å‡½æ•¸çš„èª¿ç”¨æ™‚æ©Ÿ

1ã€ç”¨å·²ç¶“å‰µå»ºçš„å°è±¡ä¾†åˆå§‹åŒ–å°è±¡
2ã€å‡½æ•¸çš„å‚³åƒ
3ã€å‡½æ•¸çš„è¿”å›å€¼

*/

// 1ã€ç”¨å·²ç¶“å‰µå»ºçš„å°è±¡ä¾†åˆå§‹åŒ–å°è±¡
void func1() {
    cout << "--------------func1--------------" << endl;
    Hero h1(20);
    Hero h2(h1);
}

void test1(Hero h) {

}

void test2(Hero* h) {

}

// 2ã€å‡½æ•¸çš„å‚³åƒ
void func2() {
    cout << "--------------func2--------------" << endl;
    Hero h1;
    // test1(h1);
    test2(&h1);
}

// 3ã€å‡½æ•¸çš„è¿”å›å€¼
Hero test3() {
    Hero h(40);
    return h;
}

void func3() {
    cout << "--------------func3--------------" << endl;
    Hero h = test3();
}

int main() {
    func1();
    func2();
    func3();
    return 0;
}
```

```cpp
    Hero(const Hero& h) { // need to use const
        m_Hp = h.m_Hp;
        cout << "Hero æ‹·è²æ§‹é€ å‡½æ•¸èª¿ç”¨å®Œç•¢ï¼" << endl;
    }

```

`const Hero&` make it unchangeable , then copy it

/_
æ‹·è²æ§‹é€ å‡½æ•¸çš„èª¿ç”¨æ™‚æ©Ÿ
1ã€ç”¨å·²ç¶“å‰µå»ºçš„å°è±¡ä¾†åˆå§‹åŒ–å°è±¡
2ã€å‡½æ•¸çš„å‚³åƒ
3ã€å‡½æ•¸çš„è¿”å›å€¼
_/

2`fun2 wont work because it the para is pointer , pointer won't create a new object so it is not going **copy the object**
you can call the function and destruct it , but missing copy there in func2 and func3

func3 will show copy success , but compiler `rvo ` optimized it , so it won't show without config

---

éœæ…‹æˆå“¡å‡½æ•¸

```cpp

#include <iostream>
#include <string>
using namespace std;

/*
éœæ…‹æˆå“¡è®Šé‡çš„ç‰¹é»ï¼š
1ã€æ‰€æœ‰çš„å°è±¡å…±äº«åŒä¸€ä»½æ•¸æ“š
2ã€ç·¨è­¯éšæ®µåˆ†é…å…§å­˜
3ã€éœ€è¦åœ¨é¡ä¸­é€²è¡Œè²æ˜ï¼Œåœ¨é¡å¤–é€²è¡Œåˆå§‹åŒ–
*/

class Hero {
public:
  Hero() {
    m_Name = "è‹±é›„";
    m_Hp = 100;
  }

  ~Hero() {}
  // 3.1 è²æ˜
  static int m_HeroCount;

private:
  string m_Name;
  int m_Hp;
};

// 3.2 åˆå§‹åŒ–
int Hero::m_HeroCount = 100;

int main() {
  Hero h;
  cout << h.m_HeroCount << endl;
  h.m_HeroCount = 101;
  cout << Hero::m_HeroCount << endl;

  cout << &(h.m_HeroCount) << endl;
  cout << &(Hero::m_HeroCount) << endl;
  return 0;
}
```

```cpp

  // 3.1 è²æ˜
  static int m_HeroCount;
// 3.2 åˆå§‹åŒ–
int Hero::m_HeroCount = 100;

  cout << h.m_HeroCount << endl;
  h.m_HeroCount = 101;
  cout << Hero::m_HeroCount << endl;

  cout << &(h.m_HeroCount) << endl;
  cout << &(Hero::m_HeroCount) << endl;

```

- they are the same address, h. and Hero::

/_
éœæ…‹æˆå“¡å‡½æ•¸
1ã€æ‰€æœ‰å°è±¡å…±äº«å‡½æ•¸
2ã€éœæ…‹æˆå“¡å‡½æ•¸åªèƒ½ä½¿ç”¨éœæ…‹æˆå“¡è®Šé‡ï¼Œç„¡æ³•ä½¿ç”¨æ™®é€šæˆå“¡è®Šé‡3. **Inside class declaration, than class outside initiate it **
_/

---

```cpp
#include <iostream>
#include <string>
using namespace std;

/*
éœæ…‹æˆå“¡å‡½æ•¸
1ã€æ‰€æœ‰å°è±¡å…±äº«å‡½æ•¸
2ã€éœæ…‹æˆå“¡å‡½æ•¸åªèƒ½ä½¿ç”¨éœæ…‹æˆå“¡è®Šé‡ï¼Œç„¡æ³•ä½¿ç”¨æ™®é€šæˆå“¡è®Šé‡
*/

class Hero {
public:
  Hero() {
    m_Name = "è‹±é›„";
    m_Hp = 100;
  }
  ~Hero() {}

  static int m_HeroCount;

  static int GetHeroCount() {
    // m_Hp += 1;
    return m_HeroCount;
  }

private:
  string m_Name;
  int m_Hp;

  static int GetHeroCount1() {
    // m_Hp += 1;
    return m_HeroCount;
  }
};

int Hero::m_HeroCount = 100;

int main() {
  Hero h;
  cout << h.GetHeroCount() << endl;
  cout << Hero::GetHeroCount() << endl;
  // h.GetHeroCount1();
  return 0;
}
```

- Static func cant' modify `   // m_Hp += 1;`

---

## thisæŒ‡é‡

```cpp
thisæŒ‡é‡
1ã€è§£æ±ºå‘½åè¡çª
2ã€*this å°±å¯ä»¥ç²å–åˆ°é€™å€‹å°è±¡æœ¬èº«

this     *this
 &h      *(&h) == h

```

```cpp
#include <iostream>
using namespace std;

/*
thisæŒ‡é‡
1ã€è§£æ±ºå‘½åè¡çª
2ã€*this å°±å¯ä»¥ç²å–åˆ°é€™å€‹å°è±¡æœ¬èº«


this     *this
 &h      *(&h) == h

*/

class Hero {
public:
  Hero(int hp) {
    this->hp = hp;
    cout << this << endl;
    cout << (*this).hp << endl;
  }
  int hp;
};

int main() {
  Hero h(100);
  cout << "what " << endl;
  cout << h.hp << endl;
  cout << &h << endl;// same as this, pointer
  cout << (*(&h)).hp << endl; //dereference
  return 0;
}
```

---

05_08_constä¿®é£¾æˆå“¡å‡½æ•¸

```cpp
  int getHp() const {
    // m_Hp = m_Hp + 1;
    return m_Hp;
  }


```

- this will not allow you to modify left hand side variable value

```cpp
#include <iostream>
#include <vector>
using namespace std;

// constant fn
class Hero {
public:
  Hero() : m_Hp(0) {} //inititae as 0

  int getHp() const {
    // m_Hp = m_Hp + 1;
    return m_Hp;
  }
  int setHp(int hp) { m_Hp = hp; }

private:
  int m_Hp;
};

int main() {
  const Hero h;
  // h.setHp(100);
  h.getHp();
  return 0;
}
```

```cpp
const Hero h;  // const objec
h.setHp() //  int getHp() const {

```

const object can only use the fn() const , as they both won't modify the left side value

---

## mutable <-> const

```cpp
private:
  int m_Hp;
  mutable int m_getHpCounter;
};

mutable // for fn() const
int getHp() const {
    m_getHpCounter++;
    return m_Hp;
  }

```

---

## å‹å…ƒ(friend)

```cpp
/*
å‹å…ƒçš„ç›®çš„

è®“ä¸€å€‹é¡ æˆ–è€… å‡½æ•¸
èƒ½å¤ è¨ªå•å¦ä¸€å€‹é¡çš„ç§æœ‰æˆå“¡

å‹å…ƒçš„é—œéµå­—ï¼š friend

ä¸‰ç¨®å‹å…ƒ
1ã€å…¨å±€å‡½æ•¸ä½œç‚ºå‹å…ƒ
2ã€é¡ä½œç‚ºå‹å…ƒ
3ã€æˆå“¡å‡½æ•¸ä½œç‚ºå‹å…ƒ
*/

```

1ã€å…¨å±€å‡½æ•¸ä½œç‚ºå‹å…ƒ
2ã€é¡ä½œç‚ºå‹å…ƒ
3ã€æˆå“¡å‡½æ•¸ä½œç‚ºå‹å…ƒ

è®“ä¸€å€‹é¡ æˆ–è€… å‡½æ•¸
èƒ½å¤ è¨ªå•å¦ä¸€å€‹é¡çš„ç§æœ‰æˆå“¡

```cpp
#include <iostream>
#include <string>
using namespace std;

/*
å‹å…ƒçš„ç›®çš„

è®“ä¸€å€‹é¡ æˆ–è€… å‡½æ•¸
èƒ½å¤ è¨ªå•å¦ä¸€å€‹é¡çš„ç§æœ‰æˆå“¡

å‹å…ƒçš„é—œéµå­—ï¼š friend

ä¸‰ç¨®å‹å…ƒ
1ã€å…¨å±€å‡½æ•¸ä½œç‚ºå‹å…ƒ
2ã€é¡ä½œç‚ºå‹å…ƒ
3ã€æˆå“¡å‡½æ•¸ä½œç‚ºå‹å…ƒ
*/

class People{
    friend void friendVisit(People* p);
public:
    People() {
        m_House = "åˆ¥å¢…";
        m_Car = "è·‘è»Š";
    }
public:
    string    m_House;

private:
    string   m_Car;
};

void friendVisit(People* p) {
    cout << "å¥½æœ‹å‹ä¾†è¨ªå•ä½ çš„" << p->m_House << endl;
    cout << "å¥½æœ‹å‹ä¾†è¨ªå•ä½ çš„" << p->m_Car << endl;
}

int main() {
    People p;
    friendVisit(&p);
    return 0;
}
```

just declared friend fn(); first -> to let them access private var

---

## 133_6-2é¡ä½œçˆ²å‹å…ƒ

```cpp
#include <iostream>
using namespace std;

// é¡ä½œç‚ºå‹å…ƒ
// è®“ä¸€å€‹é¡å»è¨ªå•å¦ä¸€å€‹é¡çš„ç§æœ‰æˆå“¡

class People; // declaration , for below visit() compile

class PeopleFriend {
public:
  PeopleFriend() {}
  void visit(People *p);
};

class People {
  friend class PeopleFriend;

public:
  People() {
    m_House = "åˆ¥å¢…";
    m_Car = "è·‘è»Š";
  }

public:
  string m_House;

private:
  string m_Car;
};

void PeopleFriend::visit(People *p) {
  cout << "å¥½æœ‹å‹ä¾†è¨ªå•ä½ çš„" << p->m_House << endl;
  cout << "å¥½æœ‹å‹ä¾†è¨ªå•ä½ çš„" << p->m_Car << endl;
}

int main() {
  People p;
  PeopleFriend pf;
  pf.visit(&p);
  return 0;
}
```

```cpp
class People; // declaration , for below visit() compile

friend class PeopleFriend;

void PeopleFriend::visit(People *p) { // using this when above declaration  don't have priate var info
  cout << "å¥½æœ‹å‹ä¾†è¨ªå•ä½ çš„" << p->m_House << endl;
  cout << "å¥½æœ‹å‹ä¾†è¨ªå•ä½ çš„" << p->m_Car << endl;
}

```

---

## 134_6-3æˆå“¡å‡½æ•¸ä½œçˆ²å‹å…ƒ.mp4

æˆå“¡å‡½æ•¸ä½œç‚ºå‹å…ƒ
PeopleFriend çš„æŸå€‹å‡½æ•¸èƒ½å¤ è¨ªå• People çš„ç§æœ‰æˆå“¡è®Šé‡

```cpp
#include <iostream>
#include <string>
using namespace std;

//  æˆå“¡å‡½æ•¸ä½œç‚ºå‹å…ƒ
// PeopleFriend çš„æŸå€‹å‡½æ•¸èƒ½å¤ è¨ªå•  People çš„ç§æœ‰æˆå“¡è®Šé‡

class People;

class PeopleFriend {
public:
  PeopleFriend() {}

  void visitAll(People *p);
  void visitPub(People *p);
};

class People {
  // friend class PeopleFriend;
  friend void PeopleFriend::visitAll(People *p);

public:
  People() {
    m_House = "åˆ¥å¢…";
    m_Car = "è·‘è»Š";
  }

public:
  string m_House;

private:
  string m_Car;
};

void PeopleFriend::visitAll(People *p) {
  cout << "å¥½æœ‹å‹è¨ªå•äº†ä½ çš„" << p->m_House << endl;
  cout << "å¥½æœ‹å‹è¨ªå•äº†ä½ çš„" << p->m_Car << endl;
}
void PeopleFriend::visitPub(People *p) {
  cout << "å¥½æœ‹å‹è¨ªå•äº†ä½ çš„" << p->m_House << endl;
  // cout << "å¥½æœ‹å‹è¨ªå•äº†ä½ çš„" << p->m_Car << endl;
}

int main() {
  People p;
  PeopleFriend pf;
  pf.visitAll(&p);
  pf.visitPub(&p);

  return 0;
}
```

---

## 135_7-1é‹ç®—ç¬¦é‡è¼‰æ¦‚å¿µ.mp4

```cpp
#include <iostream>
#include <string>
using namespace std;

/*
+
4 + 5 = 9

class A {
};

A a;
A b;
a + b;

*/
int main() {
    // 1ã€åŠ æ³•é‹ç®—ç¬¦
    int a = 520;
    int b = 1314;
    cout << a + b << endl;

    // 2ã€å­—ç¬¦ä¸²æ‹¼æ¥
    string c = "520";
    string d = "1314";
    cout << c + d << endl;

    string e = "æˆ‘";
    string f = "æ„›ä½ ";
    cout << e + f << endl;
    return 0;
}
```

`#include <string>` -> is a class

---

## 137_7-2åŠ è™Ÿé‡è¼‰.mp4

- difference btw pointer `->` and reference `x.add`

```cpp
#include <iostream>
using namespace std;

/*
+
*/
// Â¸Â´ÃŠÄ±Ã€Ã 
class Complex {
    friend Complex operator+(Complex& a, Complex& b);
    friend Complex operator-(Complex& a, Complex& b);
public:
    Complex() : real(0), image(0) {

    }
    Complex(int real, int image) {
        this->real = real;
        this->image = image;
    }
    /*
    Complex operator+(Complex& other) {
        Complex ret;
        ret.real = this->real + other.real;
        ret.image = this->image + other.image;
        return ret;
    }*/

    // a + bi
    void Print() {
        cout << real << '+' << image << 'i' << endl;
    }

private:
    int   real;
    int   image;
};

Complex operator+(Complex& a, Complex& b) {
    Complex ret;
    ret.real = a.real + b.real;
    ret.image = a.image + b.image;
    return ret;
}

Complex operator-(Complex& a, Complex& b) {
    Complex ret;
    ret.real = a.real - b.real;
    ret.image = a.image - b.image;
    return ret;
}

int main() {
    Complex a(10, 20);
    Complex b(5, 8);
    // Complex c = a.operator+(b);
    Complex c = a + b;
    Complex d = a - b;
    c.Print();
    d.Print();
    return 0;
}
```

within class fn

```cpp

    Complex operator+(Complex& other) {
        Complex ret;
        ret.real = this->real + other.real;
        ret.image = this->image + other.image;
        return ret;

```

global fn version:

```cpp
Complex operator-(Complex& a, Complex& b) {
    Complex ret;
    ret.real = a.real - b.real;
    ret.image = a.image - b.image;
    return ret;
}

```

---

## 138_7-3-1å·¦ç§»é‡è¼‰.mp4

```cpp
#include <iostream>
using namespace std;

/*
<<

Complex c;
cout.operator<<(c)

// æˆå“¡å‡½æ•¸
c.operator<<(cout)
c << cout
*/
// è¤‡æ•¸é¡
class Complex {
  friend Complex operator+(Complex &a, Complex &b);
  friend Complex operator-(Complex &a, Complex &b);
  friend ostream &operator<<(ostream &cout, Complex a);

public:
  Complex() : real(0), image(0) {}
  Complex(int real, int image) {
    this->real = real;
    this->image = image;
  }
  /*
  Complex operator+(Complex& other) {
      Complex ret;
      ret.real = this->real + other.real;
      ret.image = this->image + other.image;
      return ret;
  }*/

  // a + bi
  void Print() { cout << real << '+' << image << 'i' << endl; }

private:
  int real;
  int image;
};

Complex operator+(Complex &a, Complex &b) {
  Complex ret;
  ret.real = a.real + b.real;
  ret.image = a.image + b.image;
  return ret;
}

Complex operator-(Complex &a, Complex &b) {
  Complex ret;
  ret.real = a.real - b.real;
  ret.image = a.image - b.image;
  return ret;
}

ostream &operator<<(ostream &cout, Complex a) {
  cout << a.real << '+' << a.image << 'i';
  return cout;
}

int main() {
  Complex a(10, 20);
  Complex b(5, 8);
  // Complex c = a.operator+(b);
  Complex c = a + b;
  Complex d = a - b;
  // c.Print();
  d.Print();
  // operator<<(cout, c)
  cout << c << endl << endl;
  return 0;
}
```

The `operator<<` for `Complex` is special for these reasons:

### 1. **Stream integration**

Unlike `+` and `-`, it works with C++ streams (`cout`, `cerr`, file streams, etc.), so you can write:

```cpp
cout << c << endl;  // Instead of c.Print();
```

### 2. **Global function, not a member**

Itâ€™s a global function because:

- The left operand is `ostream&` (e.g., `cout`), not a `Complex`
- You canâ€™t modify `ostream` to add a member
- This is the standard C++ pattern for stream operators

### 3. **Chaining support**

Returning `ostream&` enables chaining:

```cpp
cout << c << endl << "Result: " << d << endl;
```

### 4. **Friend access**

Declared as `friend` to access private `real` and `image`:

```cpp
friend ostream &operator<<(ostream &cout, Complex a);
```

### 5. **Automatic invocation**

When you write `cout << c`, the compiler calls this function.

### 6. **Standard convention**

This is the idiomatic way to make custom types work with streams.

### Comparison with other operators:

- `operator+` and `operator-`: return `Complex`, can be members or globals
- `operator<<`: returns `ostream&`, must be global, enables stream output

This is why `cout << c` works instead of `c.Print()`.

---

## Chaining in C++

Chaining lets you call multiple operations in one expression. It works when each operation returns the same object (or a reference to it).

### 1. Stream Chaining (Most Common)

#### How it works:

```cpp
cout << "Hello" << " " << "World" << endl;
//     â†‘        â†‘     â†‘        â†‘
//     |        |     |        â””â”€ Returns cout
//     |        |     â””â”€ Returns cout
//     |        â””â”€ Returns cout
//     â””â”€ Returns cout
```

#### Step-by-step breakdown:

```cpp
// Step 1: cout << "Hello"
ostream& temp1 = cout.operator<<("Hello");  // Returns cout

// Step 2: temp1 << " "
ostream& temp2 = temp1.operator<<(" ");     // Returns cout

// Step 3: temp2 << "World"
ostream& temp3 = temp2.operator<<("World"); // Returns cout

// Step 4: temp3 << endl
ostream& temp4 = temp3.operator<<(endl);    // Returns cout
```

### 2. Assignment Chaining

```cpp
int a, b, c;
a = b = c = 10;  // All variables get value 10
```

#### How it works:

```cpp
// c = 10 returns c (now equals 10)
// b = (c = 10) returns b (now equals 10)
// a = (b = (c = 10)) returns a (now equals 10)
```

#### Step-by-step:

```cpp
// Step 1: c = 10
int& temp1 = c.operator=(10);  // c = 10, returns c

// Step 2: b = temp1 (which is c)
int& temp2 = b.operator=(temp1);  // b = 10, returns b

// Step 3: a = temp2 (which is b)
int& temp3 = a.operator=(temp2);  // a = 10, returns a
```

### 3. Arithmetic Chaining

```cpp
int result = 10 + 20 + 30;  // result = 60
```

#### How it works:

```cpp
// 10 + 20 = 30 (temporary)
// 30 + 30 = 60 (final result)
```

### 4. Custom Class Chaining Example

Let's create a class that supports chaining:

```cpp
class Calculator {
private:
    int value;

public:
    Calculator(int v = 0) : value(v) {}

    // Method chaining - returns *this
    Calculator& add(int n) {
        value += n;
        return *this;  // Return reference to this object
    }

    Calculator& multiply(int n) {
        value *= n;
        return *this;
    }

    Calculator& subtract(int n) {
        value -= n;
        return *this;
    }

    int getValue() const { return value; }

    // Stream operator for output
    friend ostream& operator<<(ostream& os, const Calculator& calc) {
        os << calc.value;
        return os;
    }
};
```

#### Usage:

```cpp
Calculator calc(10);
calc.add(5).multiply(2).subtract(3);  // Chaining!
cout << calc << endl;  // Output: 27

// Step by step:
// calc.add(5)     â†’ calc.value = 15, returns calc
// .multiply(2)    â†’ calc.value = 30, returns calc
// .subtract(3)    â†’ calc.value = 27, returns calc
```

### 5. The Key: Return by Reference

#### âœ… Correct (enables chaining):

```cpp
Calculator& add(int n) {
    value += n;
    return *this;  // Returns reference to this object
}
```

#### âŒ Wrong (breaks chaining):

```cpp
Calculator add(int n) {  // Returns by value (copy)
    value += n;
    return *this;  // Returns a COPY of this object
}
```

#### Why the difference matters:

```cpp
Calculator calc(10);
calc.add(5).add(3);  // What happens?

// With reference return:
// calc.add(5) returns calc (same object)
// .add(3) operates on the same calc object
// Final result: calc.value = 18

// With value return:
// calc.add(5) returns a COPY of calc
// .add(3) operates on the COPY, not the original
// Original calc.value = 15, copy.value = 18
```

### 6. More Complex Chaining Examples

#### String manipulation:

```cpp
string str = "Hello";
str.append(" ").append("World").append("!");  // str = "Hello World!"
```

#### Container operations:

```cpp
vector<int> vec;
vec.push_back(1).push_back(2).push_back(3);  // If push_back returned vector&
```

#### Function call chaining:

```cpp
class Builder {
public:
    Builder& setWidth(int w) { width = w; return *this; }
    Builder& setHeight(int h) { height = h; return *this; }
    Builder& setColor(string c) { color = c; return *this; }

private:
    int width, height;
    string color;
};

// Usage:
Builder builder;
builder.setWidth(100).setHeight(200).setColor("red");
```

### 7. When Chaining Doesn't Work

#### Functions that return void:

```cpp
void print() { cout << "Hello"; }
obj.print().print();  // ERROR! print() returns void
```

#### Functions that return different types:

```cpp
int getValue() { return 42; }
obj.getValue().add(5);  // ERROR! getValue() returns int, not object
```

#### Functions that return by value:

```cpp
Calculator add(int n) {  // Returns by value
    Calculator temp = *this;
    temp.value += n;
    return temp;  // Returns a copy
}
```

### 8. Best Practices

#### âœ… Do:

- Return references for chaining methods
- Use consistent return types
- Make chaining operations clear and intuitive

#### âŒ Don't:

- Chain operations that have side effects
- Make chains too long (hard to read)
- Return references to temporary objects

### 9. Real-World Example: Fluent Interface

```cpp
class Query {
private:
    string table;
    vector<string> columns;
    string whereClause;

public:
    Query& select(const string& cols) {
        columns.push_back(cols);
        return *this;
    }

    Query& from(const string& tbl) {
        table = tbl;
        return *this;
    }

    Query& where(const string& condition) {
        whereClause = condition;
        return *this;
    }

    string build() {
        // Build SQL query string
        return "SELECT " + join(columns, ", ") +
               " FROM " + table +
               " WHERE " + whereClause;
    }
};

// Usage:
Query query;
string sql = query.select("name, age")
                  .from("users")
                  .where("age > 18")
                  .build();
```

### Summary

Chaining works when:

1. Each operation returns the same object (or reference to it)
2. The return type matches what the next operation expects
3. You return by reference, not by value

The pattern is: **Return `*this` by reference** for method chaining, and **return the stream by reference** for stream chaining.

---

the thing why using `&` in ostrem is because it both don't want outside and inside using this cout, not even private
should use that, `&` only allow one global `cout ` for using that

---

## 140_7-4-1éå¢é‡è¼‰.mp4

![](20250302-modern-cpp/2025-10-02-04-37-57.png)

why is `a` different to `x` in here?
because missing `&` , without it, it will only add 1 and then create another new object

```cpp
Complex& operator++() {
        this->real += 1;
        return *this;
    }
```

this is `++a`

```cpp
Complex operator++(int) {
        Complex c = *this;
        this->real += 1;
        return c;
    }
```

this is `a++` , just adding (int) outthere

```cpp
Complex operator++(int) {
        Complex c = *this;// if having this , the above setting need to change it to without `&`
        this->real += 1;
        return c; //rather than return *this
    }
```

![](20250302-modern-cpp/2025-10-02-04-57-59.png)
only diff 1 , but it should be 3 , why?

turn out it is normal in cpp, that later ++ need left value

```cpp

7_04_é€’å¢è¿ç®—ç¬¦/main.cpp:67:14: error: lvalue required as increment operand
   67 |   cout << ((b++)++)++ << endl;
      |            ~~^~~

```

```cpp
  Complex &operator++() { // front : ++a, returning *this
    this->real += 1;
    return *this;
  }

  Complex operator++(int) { // later : a++, require object
    Complex c = *this; // if having this , the above setting need to change it
                       // to without `&`
    this->real += 1;
    return c; // rather than return *this
  }

```

---

## 141_7-4-2éå¢é‡è¼‰è£œå…….mp4

```cpp
#include <iostream>
using namespace std;

class Hero {
public:
  Hero() : m_Data(NULL) {}
  Hero(int data) {
    m_Data = new int;
    *m_Data = data;
  }
  // double delete
  ~Hero() {
    if (m_Data) {
      delete m_Data;
      m_Data = NULL;
    }
  }

  Hero &operator=(Hero &h) {
    // m_Data = h.m_Data;
    if (m_Data) {
      delete m_Data;
      m_Data = NULL;
    }
    m_Data = new int;
    *m_Data = *h.m_Data;
    return *this;
  }

  int *m_Data;
};

int main() {
  Hero h1(1);
  Hero h2(2);
  Hero h3(3);

  cout << h1.m_Data << endl;
  cout << h2.m_Data << endl;
  cout << "damn1" << endl;
  h1 = h2; // Ã„ÃšÂ´Ã¦ÃÂ¹Ã‚Â©
  cout << h1.m_Data << endl;
  cout << h2.m_Data << endl;
  cout << "damn" << endl;

  h3 = (h2 = h1);
  cout << h1.m_Data << endl;
  cout << h2.m_Data << endl;
  cout << h3.m_Data << endl;

  return 0;
}
```

```cpp
~Hero() {
    if (m_Data) {
      delete m_Data;
      m_Data = NULL;
    }
  }


Hero &operator=(Hero &h) {
    // m_Data = h.m_Data;
    if (m_Data) {
      delete m_Data;
      m_Data = NULL;
    }
    m_Data = new int;
    *m_Data = *h.m_Data;
    return *this;
  }
```

the key is setting up destructor , and `& ` for operator`=`, so that it will change the value directly and make double
`=` work

---

## 143_7-6é—œä¿‚é‹ç®—ç¬¦é‡è¼‰.mp4

```cpp
bool operator==(const Point& other) const {
        return m_x == other.m_x && m_y == other.m_y;
    }
```

- make it both const, const Point is for non changeable `other`, const{} is for read only

class default operator won't let you compare 2 object automatically, you have to manually make that thing

```cpp
bool operator>(const Point& other) const {
        if (*this == other) { //using above operator `==`
            return false;
        }
        if (*this < other) {
            return false;
        }
        return true;
    }
```

---

## 144_7-7å‡½æ•¸èª¿ç”¨é‹ç®—ç¬¦é‡è¼‰.mp4

```cpp
class AddFunctor {
public:
    AddFunctor() {
        m_acc = 0;
    }
    int operator() (int a, int b) {
        m_acc++;
        return a + b + m_acc;
    }
private:
    int m_acc;
}
```

vs

```cpp
int Add(int a, int b) {
    return a + b;
}
```

```cpp
int main() {
    AddFunctor add;
    cout << add(5, 6) <<endl;
    cout << add(5, 6) << endl;
    cout << add(5, 6) << endl;
    cout << add(5, 6) << endl;
    cout << add(5, 6) << endl;

    cout << Add(5, 6) << endl;
    cout << Add(5, 6) << endl;
    cout << Add(5, 6) << endl;
    cout << Add(5, 6) << endl;
    cout << Add(5, 6) << endl;

    return 0;
}
```

```cpp
//result

12
13
14
15
16
11
11
11
11
11
```

---

## 145_8-1ç¹¼æ‰¿çš„èªæ³•.mp4

```cpp
/*
*       å‹•ç‰©
*      /    \
*    è²“      ç‹—
*
* ç¹¼æ‰¿çš„èªæ³•
* class å­é¡ : ç¹¼æ‰¿æ–¹å¼ çˆ¶é¡ {}
* å­é¡ -> æ´¾ç”Ÿé¡
* çˆ¶é¡ -> åŸºé¡
*/

```

- class å­é¡ : ç¹¼æ‰¿æ–¹å¼ çˆ¶é¡ {}

```cpp
#include <iostream>
using namespace std;

/*
*       å‹•ç‰©
*      /    \
*    è²“      ç‹—
*
* ç¹¼æ‰¿çš„èªæ³•
* class å­é¡ : ç¹¼æ‰¿æ–¹å¼ çˆ¶é¡ {}
* å­é¡ -> æ´¾ç”Ÿé¡
* çˆ¶é¡ -> åŸºé¡
*/

class Animal {
public:
    void eat() {
        cout << "åƒ" << endl;
    }
};

class Cat : public Animal {
public:
    void sayHi() {
        cout << "å–µ~" << endl;
    }
};

class Dog : public Animal {
public:
    void sayHi() {
        cout << "æ±ªæ±ªæ±ª~" << endl;
    }
};

int main() {
    Cat c;
    Dog d;
    c.eat();
    d.eat();

    c.sayHi();
    d.sayHi();

    return 0;
}
```

---

## 146_8-2ç¹¼æ‰¿æ–¹å¼.mp4

```cpp
/*
ç¹¼æ‰¿æ–¹å¼

class å­é¡å : ç¹¼æ‰¿æ–¹å¼ çˆ¶é¡å {};

å…¬å…± public
ä¿è­· protected
ç§æœ‰ private

3 x 3 = 9

             |    public     |     protected      |   private
  public     |    public     |     protected      |   ç„¡æ³•è¨ªå•
  protected  |   protected   |     protected      |   ç„¡æ³•è¨ªå•
  private    |    private    |      private       |   ç„¡æ³•è¨ªå•

public:   é¡å…§å¯ä»¥è¨ªå•ï¼Œé¡å¤–ä¹Ÿå¯ä»¥è¨ªå•
protectedï¼š  é¡å…§å¯ä»¥è¨ªå•ï¼Œé¡å¤–ä¸å¯è¨ªå•ï¼Œä¸”å­é¡å¯ä»¥è¨ªå•
privateï¼š    é¡å…§å¯ä»¥è¨ªå•ï¼Œé¡å¤–ä¸å¯è¨ªå•ï¼Œä¸”å­é¡ä¸å¯è¨ªå•
*/

```

```cpp
class Animal {
public:
  int m_pub;

protected:
  int m_pro;

private:
  int m_pri;
};

class Cat : public Animal {
public:
  Cat() {
    m_pub = 1;
    m_pro = 2;
    // m_pri = 3; çˆ¶é¡ç§æœ‰æˆå“¡ï¼Œå­é¡å…¬æœ‰ç¹¼æ‰¿ï¼Œç„¡æ³•è¨ªå•
  }
};

class BossCat : public Cat {
public:
  BossCat() {
    m_pub = 1;
    m_pro = 2; // çˆ¶é¡Catä¸­ä¸æ˜¯ç§æœ‰
  }
};

void testCat() {
  Cat c;
  c.m_pub = 1;
  // c.m_pro = 2;   // è¦éº¼æ˜¯ç§æœ‰ï¼Œè¦éº¼æ˜¯ä¿è­·
}

class Dog : protected Animal {
public:
  Dog() {
    m_pub = 1;
    m_pro = 2;
    // m_pri = 3; // çˆ¶é¡ç§æœ‰æˆå“¡ï¼Œå­é¡ä¿è­·ç¹¼æ‰¿ï¼Œç„¡æ³•è¨ªå•
  }
};

class PoliceDog : public Dog {
public:
  PoliceDog() {
    m_pub = 1; // é€™å€‹è®Šé‡ï¼Œåœ¨çˆ¶é¡ Dog ä¸­ä¸€å®šä¸æ˜¯ç§æœ‰æˆå“¡
    m_pro = 2; // é€™å€‹è®Šé‡ï¼Œåœ¨çˆ¶é¡ Dog ä¸­ä¸€å®šä¸æ˜¯ç§æœ‰æˆå“¡
  }
};

void testDog() {
  Dog d;
  // d.m_pub = 1;   // è¦éº¼æ˜¯ä¿è­·ï¼Œè¦éº¼æ˜¯ç§æœ‰
  // d.m_pro = 2;   // è¦éº¼æ˜¯ä¿è­·ï¼Œè¦éº¼æ˜¯ç§æœ‰
}

class Pig : private Animal {
public:
  Pig() {
    m_pub = 1;
    m_pro = 2;
    // m_pri = 3;   // çˆ¶é¡ç§æœ‰æˆå“¡ï¼Œå­é¡ç§æœ‰ç¹¼æ‰¿ï¼Œç„¡æ³•è¨ªå•
  }
};

class WildPig : public Pig {
public:
  WildPig() {
    // m_pub = 1;   // è©²è®Šé‡åœ¨çˆ¶é¡ Pig ä¸­æ˜¯ç§æœ‰çš„
    // m_pro = 2;   // è©²è®Šé‡åœ¨çˆ¶é¡ Pig ä¸­æ˜¯ç§æœ‰çš„
  }
};

void testPig() {
  Pig p;
  // p.m_pub = 1;     // è¦éº¼æ˜¯ä¿è­·ï¼Œè¦éº¼æ˜¯ç§æœ‰
  // p.m_pro = 2;     // è¦éº¼æ˜¯ä¿è­·ï¼Œè¦éº¼æ˜¯ç§æœ‰
}

int main() { return 0; }

```

---

## 147_8-3æ§‹é€ å’Œææ§‹é †åº.mp4

```cpp
#include <iostream>
using namespace std;

/*
ç¹¼æ‰¿ä¸­ï¼Œæ§‹é€ éˆè£ï¼Œå…ˆæ§‹é€ çš„å¾Œææ§‹

d -> c -> b -> a

a b c d d c b a
*/

class Animal {
public:
  Animal() { cout << "Animal æ§‹é€ " << endl; }
  ~Animal() { cout << "Animal ææ§‹" << endl; }
};

class Cat : public Animal {
public:
  Cat() { cout << "Cat æ§‹é€ " << endl; }
  ~Cat() { cout << "Cat ææ§‹" << endl; }
};

class BossCat : public Cat {
public:
  BossCat() { cout << "BossCat æ§‹é€ " << endl; }
  ~BossCat() { cout << "BossCat ææ§‹" << endl; }
};

void Test() {
  // Animal a;
  // Cat c;
  BossCat b;
}

int main() {
  Test();
  return 0;
}
```

the order kind of like `(())`

result:
Animal æ§‹é€ 
Cat æ§‹é€ 
BossCat æ§‹é€ 
BossCat ææ§‹
Cat ææ§‹
Animal ææ§‹

----------

## 148_8-4åŒåå±¬æ€§è¨ªå•.mp4

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    Animal() {
        m_Data = 17891;
    }
    int m_Data;
};

class Cat : public Animal {
public:
    Cat() {
        m_Data = 29812;
    }
    int m_Data;
};

void Test() {
    Cat c;
    cout << c.m_Data << endl;
    cout << c.Animal::m_Data << endl;

    cout << &(c.m_Data) << endl;
    cout << &(c.Animal::m_Data) << endl;
}

int main() {

    Test();
    return 0;
}
```

the inheritance it won't overwrite the father property even having the same name , different memory location

----------
## 149_8-5åŒåå‡½æ•¸è¨ªå•.mp4

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    Animal() {

    }
    void eat() {
        cout << "å‹•ç‰©åƒæ±è¥¿" << endl;
    }
};

class Cat: public Animal {
public:
    Cat() {

    }
    void eat() {
        Animal::eat();
        cout << "è²“åƒæ±è¥¿" << endl;
    }
};


int main() {
    Cat c;
    c.eat();
    // c.Animal::eat();

    return 0;
}
```


```cpp
void eat() {
        Animal::eat(); // call back parent fn()
        cout << "è²“åƒæ±è¥¿" << endl;
    }
//or 
int main() {
    Cat c;
    c.eat();
    // c.Animal::eat(); // direct call

    return 0;
}


```


----------

## 150_8-6å¤šç¹¼æ‰¿.mp4

```cpp
#include <iostream>
using namespace std;

class BaseA {
public:
    int m_A;
    int m_Base;

    BaseA() : m_A(0), m_Base(520) {}
};

class BaseB {
public:
    int m_B;
    int m_Base;

    BaseB() : m_B(0), m_Base(1314) {}
};

class BaseC {
public:
    int m_C;

    BaseC() : m_C(0) {}
};

class Son : public BaseA, public BaseB, public BaseC {

};

int main() {
    Son s;
    s.m_A = 1;
    s.m_B = 2;
    s.m_C = 3;
    // s.m_Base = 8;
    s.BaseA::m_Base = 8;
    s.BaseB::m_Base = 9;
    cout << &s.BaseA::m_Base << endl;
    cout << &s.BaseB::m_Base << endl;
    cout << sizeof(s) << endl;

    return 0;
}
```

```cpp
class Son : public BaseA, public BaseB, public BaseC {

}
```


----------

## 151_9-1å¤šæ…‹çš„èªæ³•.mp4

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    // è™›å‡½æ•¸
    virtual void eat() {
        cout << "å‹•ç‰©åœ¨åƒæ±è¥¿" << endl;
    }
};

class Cat : public Animal {
public:
    void eat() {
        cout << "è²“åœ¨åƒæ±è¥¿" << endl;
    }
};

class Pig : public Animal {
public:
    void eat() {
        cout << "è±¬åœ¨åƒæ±è¥¿" << endl;
    }
};


// main -> test -> eat -> Animal::eat
// å‡½æ•¸å‚³åƒæ˜¯å€‹å‹•ç‰©ï¼Œä½†æ˜¯å‚³å…¥ä¸åŒçš„å‹•ç‰©ï¼Œæœƒç”¢ç”Ÿä¸åŒçš„è¡Œç‚ºï¼Œé€™å°±å«å¤šæ…‹
void eat(Animal& a) {
    a.eat();
}

void Test() {
    Cat c;
    Pig p;
    eat(c);
    eat(p);
}

int main() {
    Test();
    return 0;
}
```


- main -> test -> eat -> Animal::eat
- å‡½æ•¸å‚³åƒæ˜¯å€‹å‹•ç‰©ï¼Œä½†æ˜¯å‚³å…¥ä¸åŒçš„å‹•ç‰©ï¼Œæœƒç”¢ç”Ÿä¸åŒçš„è¡Œç‚ºï¼Œé€™å°±å«å¤šæ…‹


```cpp
virtual void eat() {
        cout << "å‹•ç‰©åœ¨åƒæ±è¥¿" << endl;
    }
```
using this allow å‡½æ•¸å‚³åƒæ˜¯å€‹å‹•ç‰©ï¼Œä½†æ˜¯å‚³å…¥ä¸åŒçš„å‹•ç‰©ï¼Œæœƒç”¢ç”Ÿä¸åŒçš„è¡Œç‚º

otherwise , it will only showå‹•ç‰©åœ¨åƒæ±è¥¿, as 
```cpp
void eat(Animal& a) { // reference to animal address , so å‹•ç‰©åœ¨åƒæ±è¥¿
    a.eat();
}
```

----------

## 152_9-2è™›å‡½æ•¸.mp4

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void eat() {
        cout << "å‹•ç‰©åœ¨åƒæ±è¥¿" << endl;
    }
    virtual void run() {
        cout << "å‹•ç‰©åœ¨è·‘" << endl;
    }
};

class Cat: public Animal {
public:
    void eat() {
        cout << "è²“åœ¨åƒæ±è¥¿" << endl;
    }
};

void eat(Animal& a) {
    Animal b;
    a.eat();
}

void Test() {
    Cat c;
    eat(c);
    cout << "Animal's size = " << sizeof(Animal) << endl;
}


int main() {
    Test();
    return 0;
}
```

the animal size = 8 -> pointer


![](20250302-modern-cpp/2025-10-03-01-02-32.png)

it overwrite the pointer `vtptr` -> address memory of parent eat


----------

## 153_9-3ç´”è™›å‡½æ•¸å’ŒæŠ½è±¡é¡.mp4

```cpp
#include <iostream>

using namespace std;

class Animal {
public:
    virtual void eat() = 0;
};

class Cat : public Animal {
public:
    virtual void eat() {
        cout << "cat is eating" << endl;
    }
};

int main() {
    Cat c;
    c.eat();

    return 0;
}
```

----------

## 154_9-4è™›ææ§‹å’Œç´”è™›ææ§‹.mp4

```cpp
#include <iostream>
using namespace std;

class BaseA {
public:
    BaseA() {}
    ~BaseA() {
        cout << "BaseA éŠ·ç‡¬äº†" << endl;
    } 
};

class SonA : public BaseA {
public:
    SonA() : m_Value(NULL) {
        m_Value = new int(10);
    }
    ~SonA() {
        cout << "SonA éŠ·ç‡¬äº†" << endl;
        delete m_Value;
    }
    int* m_Value;
};


class BaseB {
public:
    BaseB() {}
    /*virtual ~BaseB() {
        cout << "BaseB éŠ·ç‡¬äº†" << endl;
    }*/
    virtual ~BaseB() = 0;
};

BaseB::~BaseB() {
    cout << "BaseB éŠ·ç‡¬äº†" << endl;
}

class SonB : public BaseB {
public:
    SonB() : m_Value(NULL) {
        m_Value = new int(10);
    }
    ~SonB() {
        cout << "SonB éŠ·ç‡¬äº†" << endl;
        delete m_Value;
    }
    int* m_Value;
};

int main() {
    BaseA* a = new SonA();
    delete a;

    BaseB* b = new SonB();
    delete b;

    // BaseB x; æŠ½è±¡é¡ç„¡æ³•é€²è¡Œå¯¦ä¾‹åŒ–

    return 0;
}
```

```cpp
    virtual ~BaseB() {
        cout << "BaseB éŠ·ç‡¬äº†" << endl;
    }

```
- è™›ææ§‹


```cpp


class BaseB {
public:
    BaseB() {}
    /*virtual ~BaseB() {
        cout << "BaseB éŠ·ç‡¬äº†" << endl;
    }*/
    virtual ~BaseB() = 0; // virtual ~Base()
}

//with outside:
BaseB::~BaseB() { cout << "BaseB éŠ·ç‡¬äº†" << endl; }

```

- aka ç´”è™›ææ§‹


this make :

```cpp
SonB éŠ·ç‡¬äº†
BaseB éŠ·ç‡¬äº†

```

without virtual ~BaseB()=0

only 
```cpp
BaseA éŠ·ç‡¬äº†

```

after 154_9-4è™›ææ§‹å’Œç´”è™›ææ§‹

```cpp
    // BaseB x; æŠ½è±¡é¡ç„¡æ³•é€²è¡Œå¯¦ä¾‹åŒ– as a abstract class

```


----------

# data structure
- [åŸºç¡€æ•°æ®ç»“æ„ï¼ˆC++ç‰ˆæœ¬ï¼‰ - Feishu Docs](https://ufbva3m5zn.feishu.cn/mindnotes/Yvqib874vm8WA6nrryLcWW4JnHf#mindmap)


## é †åºè¡¨æ¨¡æ¿
```cpp
#include <iostream>
using namespace std;

#define eleType double

struct SequentialList {
    eleType* elements;
    int size;
    int capacity;
};

void initializeList(SequentialList* list, int capacity) {
    list->elements = new eleType[capacity]();
    list->size = 0;
    list->capacity = capacity;
}

void destroyList(SequentialList* list) {
    delete[] list->elements;
}

bool isEmpty(SequentialList* list) {
    return list->size == 0;
}

int size(SequentialList* list) {
    return list->size;
}

void insert(SequentialList* list, int index, eleType element) {
    if (index < 0 || index > list->size) {
        throw std::invalid_argument("Invalid index");
    }

    if (list->size == list->capacity) {
        int newCapacity = list->capacity * 2;
        eleType* newElements = new eleType[newCapacity]();
        for (int i = 0; i < newCapacity / 2; i++) {
            newElements[i] = list->elements[i];
        }
        delete[] list->elements;
        list->elements = newElements;
        list->capacity = newCapacity;
    }
    list->size++;
    if (list->size <= list->capacity) {
        for (int i = list->size - 1; i > index; i--) {
            list->elements[i] = list->elements[i - 1];
        }
        list->elements[index] = element;
    }
}

void deleteElement(SequentialList* list, int index) {
    if (index < 0 || index >= list->size) {
        throw std::invalid_argument("Invalid index");
    }

    for (int i = index; i < list->size - 1; i++) {
        list->elements[i] = list->elements[i + 1];
    }
    list->size--;
}

int findElement(SequentialList* list, eleType element) {
    for (int i = 0; i < list->size; i++) {
        if (list->elements[i] == element) {
            return i;
        }
    }
    return -1;
}

eleType getElement(SequentialList* list, int index) {
    if (index < 0 || index >= list->size) {
        throw std::invalid_argument("Invalid index");
    }
    return list->elements[index];
}

void updateElement(SequentialList* list, int index, eleType value) {
    if (index < 0 || index >= list->size) {
        throw std::invalid_argument("Invalid index");
    }

    list->elements[index] = value;
}

int main() {
    SequentialList myList;
    initializeList(&myList, 10);

    for (int i = 0; i < 10; i++) {
        insert(&myList, i, i * 10);
    }

    cout << "Size: " << size(&myList) << endl;
    cout << "Is empty: " << isEmpty(&myList) << endl;

    for (int i = 0; i < size(&myList); i++) {
        cout << getElement(&myList, i) << " ";
    }
    cout << endl;

    deleteElement(&myList, 5);
    updateElement(&myList, 1, 1314);

    int idx = findElement(&myList, 20);
    updateElement(&myList, idx, 520);

    cout << "Size: " << size(&myList) << endl;
    cout << "Is empty: " << isEmpty(&myList) << endl;

    for (int i = 0; i < size(&myList); i++) {
        cout << getElement(&myList, i) << " ";
    }
    cout << endl;

    destroyList(&myList);

    return 0;
}
```


----------


é¦–å­—æ¯è®Šå¤§å¯«

```cpp
#include <cstring>
#include <iostream>
#include <string>
using namespace std;

int main() {
  char s[110];
  while (gets(s)) {
    int len = strlen(s);
    for (int i = 0; i < len; i++) {
      if (i == 0 || s[i - 1] == ' ') {
        if (s[i] != ' ') {
          if (s[i] >= 'a' && s[i] <= 'z') {
            s[i] -= 'a';
            s[i] += 'A';
          }
        }
      }
    }
    printf("%s\n", s);
  }
  return 0;
}
```

---
